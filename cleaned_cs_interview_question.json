[
    {
        "question": "HTTP VS HTTPS",
        "answer": "HTTP\n: Hyper Text Transfer Protocol\n\n서버/클라이언트 모델을 따라 데이터를 주고받기 위한 프로토콜\n인터넷에서 하이퍼텍스트를 교환하기 위한 통신 규약으로 80번 포트를 사용하고 있다.\nHTTP 서버가 80번 포트에서 요청을 기다리고, 클라이언트는 80번 포트를 통해 요청한다.\n애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 동작한다.\nHTTP는 상태를 가지지 않는 stateless 프로토콜이며 Method, Path, Version, Headers, Body 등으로 구성된다.\n암호화되지 않은 평문 데이터를 전송하는 프로토콜로 비밀번호와 같은 중요한 정보를 전송하면 제 3자가 정보를 조회할 수 있어 위험하다.\n그래서 HTTPS가 등장하게 되었다."
    },
    {
        "question": "대칭키 암호화 vs 비대칭키 암호화",
        "answer": "HTTPS는 대칭키 암호화 방식과 비대칭키 암호화 방식을 모두 사용한다."
    },
    {
        "question": "HTTPS 동작 과정",
        "answer": ": HTTPS는 대칭키 암호화와 비대칭키 암호화를 모두 사용해 빠른 연산 속도와 안정성을 모두 얻는다."
    },
    {
        "question": "1.x (표준 프로토콜)",
        "answer": "Header + Body 구성\nHeader에는 URI, Request method, 여러 header 정보가 포함\n사람이 읽을 수 있는 문자열 그대로 전송\nTCP 커넥션 이용 (3-way-handshake 사용)\n커넥션 재사용\n파이프라이닝 추가 (요청에 대한 응답이 끝나기 전 다음 데이터를 미리 요청)\n..."
    },
    {
        "question": "2 (성능 향상 버전)",
        "answer": "사실 1.1보다 많은 (아래와 같은) 문제를 가짐\n\n바이너리가 아닌 텍스트로 데이터를 전송\nTCP 사용\n여전히 요청 데이터가 🔗동기적으로 진행 (1개 요청, 대기 .. 도착하면 그 다음 데이터 요청, 대기 ..)\n헤더에 중복된 데이터"
    },
    {
        "question": "3",
        "answer": "HTTP/3 프로토콜은 구글(Google)에서 주도하였으며 10년 전부터 인터넷 서비스 향상을 위해 웹 페이지 반응 속도 개선, TCP 성능 개선 등 다양한 표준화 연구 개발을 진행하였다.\n그 후 여러 검증된 인터넷 서비스 개선 기술을 지속적으로 발표하는 동시에 HTTP-over-QUIC의 명칭을 HTTP/3로 바꾸었다.\n*QUID\n: 2.0에서 TCP+TLS(3-Way-Handshake 과정)에 해당\n보안 및 향상된 성능을 제공하는 UDP기반 전송 계층 프로토콜\n상당히 가볍고 성능과 보안성을 모두 고려해 설계\n암호화된 전송을 통해 멀티 플렉싱된 스트림을 제공"
    },
    {
        "question": "RESTful",
        "answer": ": Representation State Transfer"
    },
    {
        "question": "REST 구성 요소",
        "answer": "자원(Resource): HTTP URI\n자원에 대한 행위(Verb): HTTP Method\n자원에 대한 행위의 내용(Representations): HTTP Message Pay Load"
    },
    {
        "question": "REST 특징",
        "answer": "Server-client 구조\nStateless (무상태)\nCacheable (캐시 처리 가능)\nLayered System (계층화)\nUniform Interface (인터페이스 일관성)"
    },
    {
        "question": "RESTful",
        "answer": ": REST 원리를 따르는 시스템"
    },
    {
        "question": "Thread",
        "answer": ": 프로세스 내 실행되는 여러 흐름의 단위\n프로세스의 특정한 수행 경로\n프로세스가 할당ㅂ다은 자원을 이용하는 실행의 단위라고 할 수 있다."
    },
    {
        "question": "Process",
        "answer": ": 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램\n메모리에 올라와 실행되고 있는 프로그램의 인스턴스(독립적은 개체)\nos로부터 시스템 자원을 할당받는 작업의 단위\n라고 할 수 있는데 즉, 동적인 개념으로는 실행된 프로그램을 의미한다."
    },
    {
        "question": "Multi Process",
        "answer": ": 하나의 응용 프로그램을 여러개의 프로세스로 구성하여 각 프로세스가 하나의 작업(task)을 처리하도록 하는 것"
    },
    {
        "question": "Multi Thread",
        "answer": ": 하나의 응용 프로그램을 여러 개의 스레드로 구성하고 각 스레드로 하여금 하나의 작업을 처리하는 것\n웹 서버가 대표적인 멀티 스레드 응용 프로그램"
    },
    {
        "question": "그래서 멀티 프로세스 대신 멀티 스레드를 사용하는 이유",
        "answer": "프로그램 여러 개(멀티 프로세스) vs 하나의 프로그램 안에서 여러 작업(멀티 스레드)"
    },
    {
        "question": "특징 (ACID)",
        "answer": "원자성(Atomicity)\n: 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 한다.\n일관성(Consistency)\n: 트랜잭션의 작업 처리 결과는 항상 일관성을 가져야 한다.\n독립성(Isolation)\n: 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다. (하나의 특정 트랜잭션이 완료될 때까지, 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없다.)\n영속성(Durability)\n: 트랜잭션이 성공적으로 완료 되었다면 결과는 영구적으로 반영되어야 한다."
    },
    {
        "question": "Deadlock 발생 조건",
        "answer": "교착 상태는 한 시스템 내에서 다음 네 가지 조건이 동시 성립될 때 발생한다."
    },
    {
        "question": "임계 구역(Critical Section)",
        "answer": ": 프로세스 간 공유 자원을 접근하는 데 있어 문제가 발생하지 않도록 한 번에 하나의 프로세스만 이용해 다른 프로세스들의 접근을 제한하는 영역"
    },
    {
        "question": "임계 구역 문제를 해결하기 위한 방법",
        "answer": "상호 배제(Mutual Exclution) - 스핀락, 뮤텍스\n: 하나의 프로세스가 임계 구역에 들어가 있다면 다른 프로세스는 들어갈 수 없어야 한다.\n\n\n진행(Progress)\n: 들어가려는 프로세스가 여러 개라면 어느 것이 들어갈지 결정해주어야 한다.\n\n\n한정된 대기(Bounded Waiting)\n: 다른 프로세스의 기아(Starvation)를 막기 위해 한 번 임계 구역에 들어간 프로세스는 다음번 임계 구역 접근에 제한이 생겨야 한다."
    },
    {
        "question": "스핀락 Spinlock",
        "answer": ": 특정한 자원을 획득(Lock) 또는 해제(Unlock)를 통해 공유 자원에 대한 접근 권한을 관리하는 방법"
    },
    {
        "question": "뮤텍스 Mutex",
        "answer": ": MUTual EXclusion으로 상호 배제라고도 한다."
    },
    {
        "question": "세마포어 Semaphore",
        "answer": ": 스핀락과 뮤텍스와는 다르게 하나 이상의 스레드가 공유 자원에 접근할 수 있도록 함\n(예전에 많이 사용되던 방식)"
    },
    {
        "question": "세마포어 vs 뮤텍스",
        "answer": "세마포어의 경우 여러 개의 스레드가 접근할 수 있는 반면 뮤텍스는 오직 한 개의 스레드만 접근 가능\n세마포어는 현재 수행 중인 스레드가 아닌 다른 스레드가 세마포어 해제를 할 수 있지만 뮤텍스의 경우 획득하고 해제하는 주체가 동일해야 함 (lock을 획득한 프로세스가 unlock까지)"
    },
    {
        "question": "모니터 Monitor",
        "answer": ": 상호배제 락에 의해 보호되는 일련의 루틴\n락을 획득하기 전까지는 스레드에서 모니터에 속하는 어떤 루틴도 실행시킬 수 없다."
    },
    {
        "question": "세마포어 vs 모니터",
        "answer": "세마포어에 비하여 모니터 쪽이 공유자원에 접근할 수 있는 키의 획득과 해제를 모두 처리해 간단하다.\n세마포어는 직접 키 해제와 공유자원 접근 처리를 해주어야 한다."
    },
    {
        "question": "TCP",
        "answer": ": Transmission Control Protocol\n연결형 서비스를 지원하는 프로토콜"
    },
    {
        "question": "UDP",
        "answer": ": User Datagram Protocol\n비연결형 서비스를 지원하는 프로토콜"
    },
    {
        "question": "메모리 단편화 Memory Fragmentation",
        "answer": ": 메모리 공간이 조각조각 나뉘게 되어 실제로는 사용 가능한 메모리가 충분한데도 불구하고 할당이 불가능한 상태\n(내부 단편화, 외부 단편화)"
    },
    {
        "question": "Paging",
        "answer": "프로세스는 페이지로 나누어지며 물리 메모리는 프레임으로 나뉨\n페이지 테이블에는 각 페이지 번호와 해당 페이지가 할당된 프레임의 시작 물리 주소 저장\nCPU는 논리 주소로 프로그램이 설정한대로 연속적인 주소값으로 명령을 내리고 이는 메모리로 가기 전 각 페이지의 실제 메모리 주소가 저장되어 있는 테이블에서 물리 주소로 변경\n만약 프로세스가 프레임의 정수배보다 살짝 작다면 할당된 마지막 프레임은 전부 사용되지 않고 남아버리는 내부 단편화가 발생 (페이지가 클수록 내부 단편화가 커짐)\n가상 메모리 사용"
    },
    {
        "question": "Segmentation",
        "answer": "사용자/프로그래머 관점의 메모리 관리 기법\nSegment: 페이지 같은 개념이지만, 프로세스를 논리적 내용을 기반으로 나누어 메모리에 배치\n➡️ 프로세스를 Code, Data, Stack으로 나누는 것 역시 세그멘테이션\n세그먼트 테이블은 세그먼트 번호와 시작 주소(base), 세그먼트 크기(limit)을 엔트리로 가짐\n가상 메모리 사용\nCPU에서 해당 세그먼트의 크기를 넘어서는 주소가 들어오면 인터럽트가 발생해 해당 프로세스를 강제종료"
    },
    {
        "question": "Paging vs Segmentation",
        "answer": "paging은 고정 크기를 가짐\nsegmentation은 가변 크기를 가짐\npaging은 내부 단편화 발생 가능\nsegmentation은 외부 단편화 발생 가능"
    },
    {
        "question": "paging과 segmentation을 사용하는 이유",
        "answer": "Memory fragmentation(메모리 단편화)을 해결하기 위함\n다중 프로그래밍 시스템에서 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 관리 기법이 필요함"
    },
    {
        "question": "B Tree",
        "answer": "B Tree는 밸런스 트리 (Balanced Tree)의 대표적인 예 중 하나이다."
    },
    {
        "question": "탐색 시간이 더 빠른 해시 대신 B Tree를 사용하는 이유",
        "answer": "해시 테이블은 O(1) 시간 복잡도를 가진다. (해시 충돌 등 최악의 경우에는 O(N)이 될 수 있지만 편균적으로는 O(1))"
    },
    {
        "question": "Map vs HashMap",
        "answer": "Map\n\nkey-value를 가진 집합\n중복 허용 X ➡️ 하나의 key에 하나의 value\njata.util 패키지에 여러 집합들을 사용하기 위한 여러 인터페이스와 클래스들이 정의되어 있음"
    },
    {
        "question": "List vs Array",
        "answer": "List\n\n배열이 가진 index라는 장점을 버리고 빈틈없는 데이터 적재라는 장점을 가짐\n순서가 있는 데이터 모음\n리스트에서의 인덱스 → 몇 번째 데이터인가\n(배열에서의 인덱스는 유일무이 식별자)\n비어있는 원소 허용 X\n순서를 보장하지 않아 cash hit 어려움\n데이터 개수가 정해져 있고 자주 사용된다면 List보단 Array"
    },
    {
        "question": "Stack vs Queue",
        "answer": "Stack\n\nLIFO (Last In First Out, 후입선출)\n스택의 구현은 Array 또는 Linked List\n대표적으로 프로그램을 수행할 때 사용됨\n(Main 프로그램에서 함수 A를 호출하면 Main 위에 A가 쌓이고, A 수행 중 B가 호출되면 A위 B가 스택처럼 쌓임)"
    },
    {
        "question": "운영체제에 대해 아는대로 설명해보세요.",
        "answer": "운영체제는 컴퓨터의 하드웨어와 소프트웨어 자원들을 효율적으로 관리하며 작업을 할 수 있는 환경을 제공해주는 시스템 소프트웨어입니다. 예를 들어 프로세스 관리 영역 중의 스케줄링은 여러 응용 프로그램이 동시에 실행되는 상황에서 CPU 자원을 효율적으로 할당하는 역할을 합니다. 이 밖에 운영체제의 대표적인 역할로는 메모리 및 파일 시스템과 같은 저장장치 관리, TCP/IP 및 기타 프로토콜와 관련한 네트워킹, 사용자의 계정 및 접근권한 관리 그리고 기기의 input, output 드라이버를 관리하는 역할이 있습니다.\n이러한 기능은 소프트웨어 자원을 효율적으로 활용하여 전체적인 시스템 안정성과 성능을 유지하는 데 도움이 됩니다.\n운영체제의 종류에는 Windows, UNIX, LINUX, MacOS, MS-DOS 등이 있습니다."
    },
    {
        "question": "시스템 콜에 대해 아는대로 설명해보세요.",
        "answer": "시스템 콜은 운영체제와 응용 프로그램 간의 상호작용을 위한 인터페이스로, 응용 프로그램이 운영체제의 기능을 활용할 수 있도록 돕습니다. 이러한 시스템 콜은 프로세스 제어, 파일 조작, 장치 관리, 정보 유지, 통신, 보호 등 여러 유형으로 나뉩니다. \n예를 들어 , 파일 조작 시스템 콜은 파일을 열거나, 읽고 쓰는 동작을 수행할 수 있게 합니다. 이러한 시스템 콜은 응용 프로그램이 파일 시스템과 상호작용할 수 있도록 해줍니다.\n시스템 콜이 실행되면 프로세스는 사용자 모드에서 커널 모드로 전환됩니다. 이러한 전환은 운영체제의 보호된 영역에 접근하여 필요한 작업을 수행하도록 합니다. 즉, 프로세스가 하드웨어에 직접 접근해서 필요한 기능을 할 수 있도록 도와주는 역할을 합니다. \n자바스크립트는 브라우저 환경에서 실행되는 언어로, 일반적인 운영체제 수준의 시스템 콜에 직접적으로 접근하는 것은 불가능합니다. 하지만 브라우저 환경에서 제공하는 다양한 API를 통해 파일 조작 등의 작업을 수행할 수 있습니다. File API, XMLHttpRequest 또는 Fetch API로 파일을 읽고 쓰거나 업로드 및 다운로드를 할 수 있습니다."
    },
    {
        "question": "Paging이 왜 나오게 되었고, 개념에 대해 설명해 주세요.",
        "answer": "Paging은 외부 단편화 문제를 줄이고, 효율적인 메모리 할당을 위한 메모리 관리 기법입니다.\nPaging이란 process가 할당받은 메모리 공간을 일정한 page 단위로 나누어, 물리 메모리에서 연속되지 않는 서로 다른 위치에 저장합니다. 각 processs는 주소 변환을 위해 page table을 갖게 되며, 이 page table을 통해 가상 주소가 실제 물리 메모리 주소로 변환됩니다."
    },
    {
        "question": "Paging 기법 사용시 발생할 수 있는 메모리 단편화(Memory fragmentation) 문제에 대해 설명해 주세요.",
        "answer": "메모리 단편화 문제는 저장 공간이 비효율적으로 관리되어, 용량과 성능이 저하되는 문제입니다. 그중에서 메모리 상의 비어있는 공간의 크기가 작아서, 빈 메모리 공간임에도 활용되지 못하는 문제가 외부 단편화 문제입니다. 반면 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 메모리 공간이 낭비되는 문제는 내부 단편화 문제입니다.\nPaging 기법에서는 각 process의 논리적 주소 공간과 물리적 메모리가 같은 크기의 page 단위로 나누어지기 때문에 외부 단편화 문제가 발생하지 않습니다. 하지만 process 주소 공간의 크기가 page 크기의 배수라는 보장이 없기 때문에, process의 주소 공간 중 가장 마지막에 위치한 page에서는 내부 단편화 문제가 발생할 가능성이 있습니다."
    },
    {
        "question": "Paging과 Segmentation의 차이점에 대해 설명해 주세요.",
        "answer": "둘 다 연속되지 않는 물리 메모리 공간을 process에 할당하는 메모리 관리 기법입니다. Paging은 일정한 크기인 page 단위로, Segmentation은 code, data, heap, stack과 같이 논리적 의미 단위로 나누는 것이 차이점입니다.\nPaging의 경우 메모리 분할 공간이 일정하여 내부 메모리 단편화의 문제가 발생할 수 있고, 이에 반해 Segmentation은 서로 다른 크기의 segment들이 메모리에 적재되고 제거되는 일이 반복되면 외부 메모리 단편화의 문제가 발생할 수 있습니다."
    },
    {
        "question": "Multi process에 대해 설명해보세요.",
        "answer": "Multi process는 2개 이상의 process가 동시에 실행되는 개념을 나타냅니다. 각 process는 실행파일이 memory에 적재되어 CPU에 의해 독립적으로 실행됩니다. Multi process 환경에서의 동시는 동시성(concurrency)와 병렬성(parallelism) 두 가지를 의미합니다.\n동시성은 CPU core가 1개일 때, 여러 process를 짧은 시간동안 번갈아 가면서 연산을 하게 되는 시분할 시스템으로 실행되는 것이고, 병렬성은 CPU core가 여러 개일 때, 각각의 core가 각각의 process를 연산하여 process가 동시에 실행되는 것입니다.\nMulti process 환경에서는 프로세스 간 통신과 협력이 중요한 역할을 합니다. 공유 메모리, 메시지 큐의 메커니즘을 활용하여 프로세스 간 데이터 교환과 협력이 이루어집니다. 이러한 방식으로서 다양한 작업을 동시에 처리할 수 있습니다."
    },
    {
        "question": "Multi process와 Multi thread의 차이를 설명해보세요.",
        "answer": "두 개념 보두 동시성을 달성하는 데 사용되는 주요 방법입니다. Multi thread란 하나의 process가 동시에 여러 개의 일을 수행할 수 있도록 하는 것입니다. 즉, 하나의 process에서 여러 작업을 병렬로 처리하기 위해 Multi thread를 사용합니다. Multi process는 각각 독립된 메모리 공간을 가집니다.\n\nMulti thread는 Multi process보다 적은 메모리 공간을 차지하고 Context Switching 시 캐시 메모리를 초기화할 필요가 없어 속도가 빠릅니다. 하지만 여러 thread가 동일한 자원에 동시 접근 하여 의도치 않은 값을 읽거나 수정하는 동기화 문제와 하나의 thread 장애로 전체 thread가 종료될 위험이 있습니다.\nMulti process는 하나의 process가 죽더라도 다른 process에 영향을 주지 않아 안정성이 높습니다. 반면 Multi thread와 달리 process를 생성하고 자원을 할당하는 등의 system call이 있기 때문에 많은 메모리 공간과 CPU 시간을 차지합니다.\n따라서 시스템 설게 시 작업의 특성과 환경에 따라 다르게 선택해야 합니다. 예를 들어 웹 서버에서는 Multi process를 사용하여 안정성을 확보하고, 데이터베이스 서버에서는 Multi thread를 활용하여 빠른 응답을 제공하는 것이 효과적일 수 있습니다."
    },
    {
        "question": "Multi process 환경에서 process 간 데이터를 어떻게 주고 받는지 설명해보세요.",
        "answer": "원칙적으로 process는 독립적인 주소 공간을 갖기 때문에 다른 process의 주소 공간을 참조할 수 없습니다. 하지만 경우에 따라 운영체제는 process 간의 자원 접근을 위한 메커니즘, IPC(Inter Process Communication)를 제공합니다.\n이러한 프로세스 간 통신 방법으로는 pipe, 소켓, 공유 메모리 등이 있습니다.\npipe는 단뱡향으로 데이터를 전송할 수 있으며 주로 부모-자식 프로세스 간 통신에 사용됩니다.\n소켓은 네트워크 통신을 위한 IPC 방법으로 사용되며, 클라이언트와 서버 사이에서 데이터를 주고 받을 수 있습니다.\n공유 메모리는 통신이 아닌, 데이터 자체를 공유하도록 지원합니다. 프로세스 간 메모리 영역을 공유해서 사용하도록 허용해주는 역할을 합니다.\nIPC 방법을 선택할 때는 상황에 따라 다릅니다. 파이프는 간단한 통신에, 소켓은 네트워크 통신에 적합합니다. 공유 메모리는 성능을 우선시하고자 할 때 유용합니다. 보안 측면에서는 소켓이나 파이프보다는 공유 메모리가 더 취약할 수 있습니다."
    },
    {
        "question": "process 생애 주기에 대해 설명해보세요.",
        "answer": "하나의 process는 여러 가지 상태를 가지며, 주로 실행-준비-대기 상태 등이 있습니다. process는 처음에 준비 상태에서 시작하여 CPU를 할당 받아 실행 상태로 전환됩니다. 그 후 input output 작업이나 이벤트 발생 등으로 대기 상태에 전환될 수도 있고, 다른 process가 CPU를 요청할 때 준비 상태도 전환될 수 있습니다.\n이때 process는 매우 짧은 시간동안 CPU를 점유하여 일정 부분의 명령을 수행하고, 다른 process에게 넘깁니다. 그 후 차례가 되면 다시 CPU를 점유하여 명령을 수행합니다. 따라서 이전에 어디까지 수행했고, register에는 어떤 값이 저장되어 있었는지에 대한 정보가 필요하게 되는데 이런 총제적인 정보가 바로 context입니다. context는 PCB(Process Control Block)에 저장됩니다.\nPCB는 운영 체제가 프로세스를 표현한 자료구조입니다. 프로세스 상태, 고유 번호, 다음 실행할 명령어 주소, register 값, 메모리 제한 등 프로세스의 중요한 정보가 담겨 있어 보호된 메모리 영역 안에 저장됩니다.\nprocess끼리 CPU 제어권이 옮겨지는 것을 Context switch라고 합니다. 이때 이전의 프로세스 상태를 PCB에 저장하여 보관하고 새로운 프로세스의 PCB를 읽어서 보관된 상채를 복구하는 작업이 이루어집니다. Context switch의 비용을 최소화하기 위해서는 process 스케줄링 알고리즘의 효율적인 설계와 멀티코어 프로세싱을 활용하는 등의 방법이 사용됩니다."
    },
    {
        "question": "deadlock은 언제 발생하게 되나요?",
        "answer": "deadlock은 둘 이상의 process나 스레드가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황을 말합니다.\ndealock은 상호 배제, 점유 대기, 비선점, 순환 대기 조건이 동시에 성립해야 발생합니다. 상호 배제는 한번에 한 process만 점유할 수 있는 상황이고, 점유 대기는 process가 자원을 보유한 상태에서 다른 process가 해당 자원을 추가적으로 기다리고 있는 상황입니다. 비선점은 다른 process가 사용 중인 자원을 강제로 선점할 수 없는 상황이고, 순환 대기는 대기 중인 process들이 순환 형태로 자원을 대기하는 상황을 말합니다.\n예를 들어 두 개의 프로세스 A, B가 각각 자원 X, Y를 보유하고, 서로가 가진 자원을 대기하면서 무한 대기 상태에 빠진다고 가정할 수 있습니다. 이때 A는 X를 가지고 있는 동시에 B가 가진 Y를 기다리고 있고, 반대로 B는 Y를 가지고 있는 동시에 A가 가진 X를 기다리고 있어 순환 대기 조건이 성립하게 됩니다."
    },
    {
        "question": "deadlock은 어떻게 해결할 수 있나요?",
        "answer": "deadlock의 해결방법으로는 무시, 예방, 회피, 탐지-회복이 있습니다.\n무시는 deadlock 발생 확률이 낮은 시스템에서 아무런 조치를 취하지 않고 deadlock을 무시하는 방법입니다. 현대 시스템에서는 deadlock이 잘 발생하지 않고, 시스템 성능 저하가 없기 때문에 무시 기법이 많이 사용됩니다.\n예방은 deadlock 상태 발생 조건 중 하나를 제거하는 기법입니다. 예를 들어 자원에 고유번호를 할당한 후 순서대로 자원을 요구하는 순환 대기 조건이 성립하지 않도록 하는 것이 가장 현실적입니다. 그러나 자원 사용의 효율성이 떨어지고 비용이 크다는 것이 단점입니다.\n회피는 process가 앞으로 자원을 어떻게 요청할 지에 대한 정보를 통해 순환 대기 상태가 발생하지 않도록 자원을 할당하는 기법입니다. 대표적인 예로 은행원 알고리즘, 자원 할당 그래프 알고리즘을 사용하여 자원을 할당하여 deadlock을 회피합니다. 이 기법은 자원 요청에 대한 정보가 미리 알려져 있어야 하는 제약이 있습니다.\n마지막으로 탐지-회복은 시스템 검사로 deadlock 발생을 탐지하고, 이를 회복하는 기법입니다. deadlock 상태를 일으킨 프로세스를 종료하거나 할당된 자원을 해제시켜 회복합니다. 이 기법은 예방과 마찬가지로 자원 사용의 효율성이 떨어지고 비용이 크다는 것이 단점입니다.\n이러한 방법은 각각의 장단점이 있으며, 상황과 시스템 요구에 따라 적절한 방법을 선택해야 합니다."
    },
    {
        "question": "Race Condition에 대하여 간단한 예시를 들어 설명해 주세요.",
        "answer": "Race Condition은 여러 프로세스나 스레드가 동시에 공유된 자원을 조작할 때 타이밍에 따라 결과가 달라질 수 있는 상황을 의미합니다.\n예를 들어 동시에 실행되는 두 스레드 A, B가 공유 변수 balance에 동시에 접근하며, 각각의 스레드는 데이터에 입금 및 출금하는 로직을 수행한다고 가정하겠습니다. 만약 스레드 A가 balance를 읽고 200을 출금하려는 도중, 스레드 B가 balance를 읽고 100을 입금한다면 서로의 작업이 겹쳐서 balance에 대한 최종값이 예측 불가능해질 수 있습니다.\n이러한 Race Condition을 방지하기 위해서는 동기화 메커니즘이 필요합니다. 대표적으로 뮤텍스를 사용할 수 있습니다. 뮤텍스는 상호배제를 제공하여 임계 구역에 대한 동시 접근을 막는 동기화 메커니즘입니다. 뮤텍스는 공유 자원을 점유하는 thread가 lock을 걸면, 다른 thread는 unlock 상태가 될 때까지 해당 자원에 접근할 수 없도록 합니다. 해당 기법을 통해 한 번에 하나의 스레드만이 공유 자원에 안전하게 접근할 수 있도록 만들 수 있습니다."
    },
    {
        "question": "뮤텍스와 세마포어 차이점에 대해 설명해 주세요.",
        "answer": "뮤텍스와 세마포어 둘 다 동기화 메커니즘으로, 여러 프로세스 또는 스레드 간에 공유된 자원에 안전하게 접근하기 위해 사용됩니다.\n뮤텍스는 mutual exclusion, 상호 배제의 약어로, 임계 구역에 대한 동시 접근을 막는 데 사용됩니다. 공유 자원에 접근할 수 있는 프로세스 및 스레드 수를 1개로 제한합니다. 뮤텍스는 주로 lock, unlock의 두 가지 연산을 통해 구현됩니다.\n세마포어는 공유 자원에 대한 접근을 여러 프로세스 또는 스레드로 제한할 수 있습니다. 변수 세마포에 접근 가능한 자원의 수를 저장하고 임계 영역 출입 여부에 따라 해당 변수를 제어합니다. 세마포어는 주로 P(wait), V(signal)의 두 가지 기본 연산을 통해 구현됩니다."
    },
    {
        "question": "CPU 스케줄링은 왜 필요하나요?",
        "answer": "스케줄링은 프로세스가 생성되고 실행될 떄 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업을 의미합니다. 실행되고 있는 프로세스에게 CPU가 공평하게 할당되고, 응답 시간과 반환 시간을 최소화하기 위해 필요한 작업입니다. 특히나 다중 프로그래밍 환경에서는 CPU는 한정된 자원이기 때문에 이 작업을 최대한 활용하려 대기 중인 프로세스들이 적절한 시간에 실행되도록 해야합니다.\n요약하자면, CPU 스케줄링은 시스템의 공평성, 응답성, 효율성을 향상시키기 위한 핵심적인 관리 작업으로써 필요합니다."
    },
    {
        "question": "CPU 스케줄링의 종류와 각 종류 별 예시를 하나 들어주세요.",
        "answer": "스케줄링은 우선순위가 높은 프로세스가, 실행되고 있는 프로세스의 CPU를 강제로 뺴앗을 수 있는 여부에 따라 선점, 비선점으로 구분됩니다.\n비선점 스케줄링은 프로세스 응답 시간의 예측이 용이하지만, 중요한 작업이 중요하지 않은 작업을 기다리는 경우가 발생할 수 있습니다. 대표적인 예로 First Come First Served가 있습니다. 큐에 도착한 순서대로 CPU가 할당되는 것을 특징으로 가집니다.\n선점 스케줄링은 우선순위가 높은 프로세스가 빠르게 처리되지만 많은 오버헤드를 발생시킬 수 있습니다. 대표적인 예로 Round Robin이 있습니다. 앞서 제시한 FCFS에 의해 프로세스들의 보내지면 각 프로세스는 동일한 시간의 최소 단위 시간만큼 CPU를 할당 받습니다. 즉, 할당 시간이 크면 FCFS와 동일하게 작동되고, 작으면 Context Switching이 잦아져서 오버헤드가 증가합니다.\n스케줄링은 다양한 방식으로 CPU를 효과적으로 관리하고 각각의 장단점이 있습니다. 그래서 운영체제의 목적, 사용 환경에 따라 선택하는 종류가 달라집니다."
    },
    {
        "question": "stack이 무엇이며, 어떤 상황에서 사용되는지 설명해 주세요.",
        "answer": "stack은 LIFO(Last In First Out)의 자료구조입니다. 시간복잡도는 원소를 추가하는 push의 경우 O(1), 가장 마지막에 추가한 원소를 뽑아내는 pop의 경우 O(1)입니다. 활용 예시는 후위 표기법 연산, 괄호 유효성 검사, 웹 브라우저 방문기록(뒤로 가기), 깊이우선탐색(DFS) 등이 있습니다."
    },
    {
        "question": "stack 두 개를 이용하여 queue를 구현해 주세요.",
        "answer": "enqueue를 구현하는 stack을 instack, dequeue를 구현하는 stack을 outstack이라고 가정하겠습니다. 첫 번째로 enqueue하는 것은 stack의 push와 동일하게 구현할 수 있습니다. dequeue를 구현하기 위해서 instack을 pop한 것을 순서대로 outstack에 push합니다. instack이 빌 때까지 해당 작업을 수행한 뒤 outstack을 pop하면 dequeue를 구현할 수 있습니다."
    },
    {
        "question": "stack을 사용하여 괄호 검사를 수행하는 알고리즘에 대해 설명해 주세요.",
        "answer": "검사할 문자열을 처음부터 하나씩 꺼내 여는 괄호(()에 해당하면 stack에 push합니다. 만약 닫는 괄호())에 해당하면 stack에 여는 괄호를 pop합니다. 이 경우 stack이 비어 있다면 올바른 괄호로 이루어진 문자열이 아닌 것을 파악할 수 있습니다.\n해당 알고리즘은 코드 편집기나 컴파일러에서 괄호의 쌍을 확인하여 문법 오류를 방지하는 데 활용할 수 있습니다."
    },
    {
        "question": "원형 queue와 일반 queue의 차이점에 대해 설명해 주세요.",
        "answer": "원형 queue는 크기가 정해져 있는 array-based queue를 구현할 때 주로 쓰는 형식입니다.\nfront가 가장 첫 인덱스로 고정되어 있지 않고, dequeue에 따라서 이동합니다. rear 또한 enqueue에 의해 뒤로 이동하며 인덱스가 queue의 크기를 넘어설 경우 0으로 이동하여 구현합니다. 따라서 enqueue와 dequeue 과정에서 남는 메모리가 생길 수 있습니다.\n일반 queue는 크기가 정해져 있지 않는 list-based이며 재할당이나 메모리 낭비의 걱정을 할 필요가 없습니다."
    },
    {
        "question": "우선순위 큐에 대해 설명하고, 어떤 상황에서 이를 활용할 수 있을지 설명해 주세요.",
        "answer": "시간순서가 아닌 우선순위가 높은 순서로 dequeue할 수 있는 queue가 priority queue입니다.\n활용 예시로는 하나의 자원을 공유하는 프린터나, CPU task scheduling, Cache구현, 너비우선탐색(BFS) 등이있습니다."
    },
    {
        "question": "queue 두 개를 이용하여 stack을 구현해 주세요.",
        "answer": "queue1, queue2가 있다고 가정하겠습니다. push를 구현하기 위해 queue1에 enqueue합니다. pop을 구현하기 위해서는 queue1의 원소의 개수가 1이 될 때까지 queue1을 dequeue하여 queue2에 enqueue합니다. queue1에 하나 남은 원소를 dequeue하여 pop의 결과를 반환합니다. 마지막으로 queue1과 queue2를 swap하여 다음 pop을 대비하면 됩니다."
    },
    {
        "question": "동적 배열(Dynamic Array)의 개념과 장점에 대해 설명하고, 내부 구현 방식에 대해 이야기해 주세요.",
        "answer": "정적 배열인 Array는 size가 고정되어 있어, 선언시에 설정한 size보다 많은 갯수의 요소를 추가할 수 없습니다. 이때, 기존의 size보다 더 큰 Array를 선언하여 데이터를 옮겨 메모리 블록에 할당합니다. 모든 데이터를 옮겼다면 기존 Array는 메모리에서 삭제합니다. 이런식으로 동적으로 배열의 크기를 조절하는 자료구조를 Dynamic Array라고 합니다.\nDynamic Array는 저장공간이 가득 차게 되면 resize를 하여 유동적으로 size를 조절하기 때문에 size를 예측할 수 없는 상황에서 유용합니다."
    },
    {
        "question": "연결 리스트(Linked List)의 특징과 배열(Array)과의 비교점에 대해 설명해 주세요.",
        "answer": "Array는 메모리 상에서 연속적으로 데이터를 저장하는 자료구조입니다. Linked List는 메모리상에서는 연속적이지 않지만, 각각의 원소가 다음 원소의 메모리 주소값을 저장해 놓음으로써 논리적 연속성을 유지합니다.\n그래서 각 operation의 시간복잡도가 다릅니다. 데이터 조회는 Array의 경우 O(1), Linked List는 O(n)의 시간복잡도를 갖습니다. 삽입/삭제에서 Array의 경우 O(n), Linked List는 O(1)의 시간복잡도를 갖습니다.\n따라서 얼마만큼의 데이터를 저장할지 미리 알고있고, 조회를 많이 한다면 Array를 사용하는 것이 좋습니다. 반면에 몇개의 데이터를 저장할 지 불확실하고 삽입 삭제가 잦다면 Linked List를 사용하는 것이 유리합니다."
    },
    {
        "question": "Dynamic Array를 Linked list와 비교하여 장단점을 설명해 주세요.",
        "answer": "Linked List와 비교했을 때, Dynamic Array의 장점은 데이터 접근과 할당이 O(1)로 굉장히 빠릅니다. 이는 index 접근하는 방법이 산술적인 연산 [배열 첫 data의 주소값] + [offset]으로 이루어져 있기 때문입니다. 그리고 Dynamic Array의 맨 뒤에 데이터를 추가하거나 삭제하는 것이 상대적으로 빠릅니다.(O(1))\nLinked List와 비교했을 때, Dynamic Array의 단점은 Dynamic Array의 맨 끝이 아닌 곳에 data를 삽입 또는 제거할 때, 느린 편입니다(O(n)). 느린 이유는 메모리상에서 연속적으로 데이터들이 저장되어 있기 때문에, 데이터를 추가 삭제할 때 뒤에 있는 data들을 모두 한칸씩 shift 해야되기 때문입니다. 그리고 Dynamic Array의 특성 상 resize를 해야할 때, 예상치 못하게 현저히 낮은 performance가 발생합니다. resize에 시간이 많이 걸리므로 필요한 것 이상 memory공간을 할당받습니다. 따라서 사용하지 않고 있는 낭비되는 메모리공간이 발생합니다."
    },
    {
        "question": "단일 연결 리스트와 이중 연결 리스트의 차이에 대해 설명하고, 각각의 장단점을 언급해보세요.",
        "answer": "Linked List는 각 노드가 데이터와 다음 노드를 가리키는 포인터로 이루어진 자료 구조입니다. 이때 가리키는 방향이 다음 노드 뿐일 때, 단일 연결 리스트라 말하고, 가리키는 방향이 이전 노드도 포함되어 있을 때 이중 연결 리스트라고 말합니다.\n단일 연결 리스트는 메모리를 효율적으로 사용하고 삽입 및 삭제가 간편하지만 역방향 탐색이 어렵다는 단점을 가지고 있습니다. 이중 연결 리스트는 양방향 탐색이 가능하고 역방향으로 노드를 삽입하고 삭제하기 용이합니다. 반면 단일 연결 리스트와 비교하여 메모리 사용량이 더 많고 복잡한 구현이 필요하다는 단점을 가지고 있습니다."
    },
    {
        "question": "연결 리스트를 사용하여 역순으로 노드를 출력하는 알고리즘에 대해 설명해 주세요.",
        "answer": "# python\nclass Node:\n  def __init__(self, data):\n    self.data = data\n    self.next = None\n\ndef reverse_and_print(head):\n  prev = None\n  current = head\n\n  while current:\n    next_node = current.next\n    current.next = prev\n    prev = current\n    current = next_node\n\n  while prev:\n    print(prev.data)\n    prev = prev.next\n\nhead = Node(1)\nhead.next = Node(2)\nhead.next.next = Node(3)\nreverse_and_print(head)"
    },
    {
        "question": "힙(Heap)의 개념을 설명하고, 최소 힙(Min Heap)과 최대 힙(Max Heap)의 차이에 대해 이야기해보세요.",
        "answer": "Heap은 우선순위큐(priority queue)로 만들어진 자료구조입니다. Heap은 시뮬레이션 시스템, 작업 스케줄링, 수치해석 계산 등에 활용될 수 있습니다.\nHeap은 완전이진트리 구조를 가집니다. 트리는 보통 Linked list로 구현하지만 Heap은 tree임에도 불구하고 array를 기반으로 구현해야 합니다. 그 이유는 새로운 node를 힙의 ‘마지막 위치’에 추가해야 하는데, 이 때 array기반으로 구현해야 이 과정이 수월해지기 때문입니다. 예를 들어 부모 노드의 인덱스가 i라면 왼쪽 자식 노드는 2i, 오른쪽 자식 노드는 2i+1가 됩니다.\nHeap이 되기 위한 조건은 최소 힙인지 최대 힙인지에 따라 나뉩니다. 최소 힙일 경우 첫째, 각 node에 저장된 값은 child node들에 저장된 값보다 작거나 같다. 둘째, root node에 저장된 값이 가장 작은 값이 된다. 최대 힙일 경우 반대가 됩니다. 따라서 dequeue를 할 때마다 최소 힙일 경우 항상 트리 내의 가장 작은 값이 도출되고, 최대 힙일 경우 항상 트리 내의 가장 큰 값이 도출됩니다."
    },
    {
        "question": "해시 테이블(Hash Table)을 사용하여 데이터를 검색하는 과정과 시간 복잡도를 설명해보세요.",
        "answer": "Hash Table은 효율적인 탐색을 위한 자료구조로써 key-value쌍의 데이터를 입력받습니다. Hash Function에 key값을 입력으로 넣어 얻은 해시값 h(k)를 위치로 지정하여 key-value 데이터 쌍을 저장합니다. 삽입, 삭제, 검색의 시간복잡도는 모두 O(1)입니다."
    },
    {
        "question": "해시 함수(Hash Function)의 역할과 특징을 설명해보세요.",
        "answer": "Hash Function은 Hash Table에서 key값을 인자로 하고 메모리 슬롯 index, 즉 해시값을 반환하는 함수로, 데이터 값을 해시 값으로 매핑하는 역할을 가지고 있습니다.\n각 상황마다 좋은 Hash Function은 달라질 수 있으나 대략적인 기준은 연산 속도가 빨라야 하고, 해시값이 최대한 겹치지 않아야 합니다."
    },
    {
        "question": "해시 충돌(Hash Collision)이 발생하는 경우의 해결 방법에 대해 설명하고, 각 방법의 장단점을 언급해보세요.",
        "answer": "Hash Collision이란 서로 다른 key의 해시값이 똑같은 경우를 말합니다. 즉, 중복되는 key는 없지만 해시값은 중복될 수 있는데 이 때 collision이 발생했다고 합니다.\n따라서 collision이 최대한 적게 나도록 Hash Function을 잘 설계해야하고, 어쩔 수 없이 collision이 발생하는 경우 연결리스트로 노드를 계속 추가해나가는 seperate chaining 방법을 선택할 수 있습니다. 쉽고 간단하게 구현이 가능하지만 메모리 소비가 증가하는 단점을 가지고 있습니다. 또는 해시 함수로 얻은 주소가 아닌 다른 주소에 데이터를 저장할 수 있도록 허용하는 open addressing등의 방법을 사용하여 해결합니다. 이는 추가적인 메모리 사용이 적지만 클러스터링과 선형 검색에 의한 성능 저하가 발생할 수 있습니다."
    },
    {
        "question": "트리(Tree)의 기본 개념을 설명하고, 이진 트리(Binary Tree)의 특징에 대해 이야기해보세요.",
        "answer": "트리는 계층 구조를 표현하는 자료구조로, 값을 가진 node와 노드들을 이어주는 edge로 이루어집니다. 트리에는 사이클이 존재할 수 없고, 루트에서 어느 노드로 가는 경로는 유일합니다. 그리고 노드의 개수가 N개 이면 간선은 N-1개로 정해져 있습니다.\n이진 트리는 각 노드가 최대 두 개의 자식 노드을 가지는 트리 구조입니다. 이진 트리 높이가 h라면, 노드의 수는 최소 h, 최대 2^(h+1)-1개 입니다. 이진 트리는 정렬된 데이터를 효율적으로 탐색하기 위해 사용될 수 있습니다."
    },
    {
        "question": "이진 탐색 트리(Binary Search Tree)의 개념과 장점에 대해 설명하고, 탐색 연산에 대한 시간 복잡도를 언급해보세요.",
        "answer": "이진 탐색 트리는 이진 트리 자료구조에서 두 가지 특징을 더한 자료구조입니다. 첫째, 각 노드의 왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 커야 합니다. 둘째, 중복된 노드가 없어야 합니다. 이진 탐색 트리의 순회는 왼쪽-루트-오른쪽 순인 중위순회 방식을 가집니다.\n탐색 연산에서 균등 트리일 경우 O(logn)을 가지고, 편향 트리인 경우 O(n)을 시간 복잡도로 가집니다."
    },
    {
        "question": "트리 순회(Tree Traversal) 방법 중 중위(In-order) 순회에 대해 설명하고, 어떤 상황에서 유용한지 알려주세요.",
        "answer": "중위 순회는 왼쪽-루트-오른쪽 순으로 순회하는 방식입니다. 이 순회 방식은 이진 탐색 트리에서 노드를 오름차순으로 방문할 수 있게 합니다."
    },
    {
        "question": "Binary Search에 대해 아는대로 설명해 주세요.",
        "answer": "Binary search는 탐색 범위를 두 부분으로 분할하면서 찾는 방식으로 O(N)의 시간복잡도를 갖는 완전탐색에 비해 O(logN)의 시간복잡도를 가져 효율적입니다. 정렬된 상태에서만 사용 가능한데, 이는 중간값을 찾아내어 찾고자 하는 값이 중간값보다 작으면 왼쪽 부분, 크면 오른쪽 부분으로 범위를 좁혀가는 방식으로 동작하기 때문입니다.\n탐색 범위를 양 끝을 의미하는 left, right pivot을 정하고 중간값에 해당하는 middle의 값을 구하고자 하는 값과 비교합니다. 이 때 구할 값이 middle보다 큰 경우 left= middle+1, 구할 값이 middle보다 낮은 경우 right=middle-1로 지정합니다. 이를 left가 right의 값을 넘어설 때까지 반복합니다."
    },
    {
        "question": "Bubble Sort에 대해서 아는대로 설명해 주세요.",
        "answer": "Bubble Sort는 서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환하며 정렬하는 알고리즘입니다.\n1회전에 첫 번째 원소와 두 번째 원소를, 두 번째 원소와 세 번째 원소를, 마지막-1 번째 원소와 마지막 번째 원소를 비교하여 조건에 맞지 않으면 교환합니다. 1회전을 수행하면 가장 큰 원소가 맨 뒤로 이동하므로 2회전은 마지막-2 번째 원소와 마지막-1 번째 원소까지만 비교합니다."
    },
    {
        "question": "Selction Sort에 대해서 아는대로 설명해 주세요.",
        "answer": "Selection Sort는 정렬 순서에 따라 원소를 넣을 위치는 이미 정해져 있고 어떤 원소를 넣을지 선택하는 정렬 알고리즘입니다.\n오름 차순 정렬이라고 가정하겠습니다. 주어진 배열 중에 최솟값을 찾고 그 값을 맨 앞에 위치한 값과 교체합니다. 그런 다음 맨 처음 위치를 뺀 나머지 배열을 동일한 방법으로 교체합니다."
    },
    {
        "question": "Insertion Sort에 대해서 아는대로 설명해 주세요.",
        "answer": "Insertion Sort는 두 번째 원소부터 시작하여 앞의 원소와 비교하여 삽입할 위치를 지정한 후, 원소를 뒤로 옮기면서 지정된 자리에 삽입하여 정렬하는 알고리즘입니다."
    },
    {
        "question": "Quick Sort에 대해서 아는대로 설명해 주세요.",
        "answer": "Quick sort는 분할 정복 알고리즘 중 하나입니다.\n리스트 가운데서 하나의 원소를 고르고, 해당 원소를 피벗으로 설정합니다. 피벗 앞에는 피벗보다 작은 모든 원소들이, 뒤에는 피벗보다 큰 모든 원소들이 오도록 리스트를 둘로 나눕니다. 이러한 분할 작업 이후에는 피벗을 고정시켜 놓고, 두 분할된 리스트에 대해 재귀적으로 이 과정을 반복합니다. 재귀는 리스트의 크기가 0이나 1이 될 때까지 반복합니다."
    },
    {
        "question": "Quick sort가 최악의 시간 복잡도를 가지는 경우 해결방안은 무엇인가요?",
        "answer": "Quick sort는 피벗 선택이 최악의 경우, 리스트가 이미 정렬되어 있거나 피벗이 항상 최대 또는 최소값을 선택하는 경우 최악의 시간 복잡도를 가질 수 있습니다.\n이런 경우 피벗을 무작위로 선택하거나 리스트 내의 중간값을 선택하는 방법을 통해 최악의 경우를 피할 수 있습니다."
    },
    {
        "question": "Merge Sort에 대해서 아는대로 설명해 주세요.",
        "answer": "Merge sort는 분할 정복 방법으로 구현되는 정렬 알고리즘입니다.\n리스트를 더 작은 서브리스트로 나누는 분할 단계 다음, 각 서브리스트를 정렬하고 합병하는 과정을 재귀적으로 가집니다."
    },
    {
        "question": "Heap Sort에 대해서 아는대로 설명해 주세요.",
        "answer": "Heap sort는 Heap 자료구조를 기반으로 하는 정렬 알고리즘입니다. Heap은 완전 이진 트리로 구성되며 최대 힙 또는 최소 힙의 성질을 가집니다.\n최대 힙을 사용하는 경우를 기준으로 힙 정렬 알고리즘에 대해 설명하겠습니다. 최대 힙을 생성한 후 루트 노드와 배열의 마지막 노드를 교환합니다. 힙의 크기를 1 감소시킨 다음 루트 노드에 대해 heapify를 재귀 호출하여 전체 트리를 최대 힙으로 만듭니다. 이 과정을 힙의 크기가 1이 될 때까지 반복합니다. 이 과정을 반복하면 정렬된 배열을 만들 수 있습니다."
    },
    {
        "question": "Radix Sort에 대해서 아는대로 설명해 주세요.",
        "answer": "비교 정렬은 수학적인 한계로 최선의 시간복잡도가 O(N*logN)보다 개선될 수 없습니다.\n그래서 비교하지 않고 수의 특성을 이용해 sort를 하는 것으로 시간복잡도를 개선시킬 수 있습니다.\nRadix sort는 일의 자리부터 시작해 각 자릿수 별로 정렬한 결과를 0-9까지의 버킷에 담는 그룹화를 진행합니다. 목록으로 다시 구성할 때에는 버킷에 이미 있는 순서대로 두는 것을 최대 수의 자릿 수만큼까지 반복합니다. 자릿수를 선택하는 기준은 가장 큰 자릿수부터 그룹화하는 Most Significant Digit과 가장 작은 자릿수부터 그룹화하는 Least Significant Digit이 있습니다.\nRadix sort는 k가 수의 자릿수일 때항상 O(N*k)의 시간복잡도를 가집니다. 공간복잡도는 O(N+k)만큼을 가집니다.\n(여기서 모든 수가 고유하고 무작위로 분산된 데이터를 다룰 경우에는 k는 logN과 동일하게 작동됩니다.)\nRadix Sort는 정수에 대해서 주로 사용되며, 음수 또는 부동 소수점 수와 같은 다른 형태의 숫자에는 적합하지 않을 수 있습니다. 또한, 알고리즘이 각 자릿수에 따라 정렬하기 때문에 정수의 자릿수가 크면 성능이 떨어질 수 있습니다.\nRadix Sort의 장점은 안정성과 시간 복잡도의 선형성입니다. 그러나 데이터가 정수이어야 하며, 다른 정렬 알고리즘에 비해 상대적으로 느린 성능을 보일 수 있습니다. 이를 통해 Radix Sort의 특징과 한계를 잘 이해하면서 적절한 상황에서 사용할 수 있습니다."
    },
    {
        "question": "Count Sort에 대해서 아는대로 설명해 주세요.",
        "answer": "Count sort는 Radix sort과 마찬가지로 정수 내지 정수로 표현할 수 있는 자료에 대한 정렬 알고리즘 중 하나로, 비교 없이 특정 범위의 정수 자료를 정렬하는 데 효과적입니다.\n먼저 정렬하는 데이터의 범위를 기반으로 각 값의 빈도를 저장하는 카운트 배열을 생성합니다. 입력 배열을 순회하면서 각 값의 빈도를 카운트 배열에 저장합니다. 그런 다음 카운트 배열의 요소를 누적합의 결과로 덮어씌워 각 값의 마지막 인덱스를 저장합니다. 입력 배열을 뒤에서부터 순회하면서 해당 값의 빈도를 이용해 정렬된 배열을 구성합니다. 정렬된 배열을 생성하면서 해당 값의 빈도를 감소시킵니다.\nCount sort의 시간복잡도는 O(N*k)이고, 공간복잡도는 O(k)입니다.\n안정 정렬이고 효율적인 시간복잡도를 가지지만 데이터가 정수 또는 정수로 표현 가능한 자료여야합니다."
    },
    {
        "question": "데이터베이스",
        "answer": "데이터 베이스에서 사용되는 키 다섯 가지를 설명해 주세요."
    },
    {
        "question": "데이터 베이스에서 사용되는 키 다섯 가지를 설명해 주세요.",
        "answer": "데이터 베이스에서의 키는 조건에 만족하는 레코드를 찾거나 정렬할 때 기준이 되는 속성 또는 속성의 집합을 뜻합니다. 이는 유일성, 최소성, 참조에 따라 다섯 가지가 있습니다.\n슈퍼 키(Super Key)는 유일성만을 보장하는 키입니다. 어떤 속성의 조합이든 각 레코드를 구별할 수 있다면 해당 속성을 슈퍼 키가 될 수 있습니다.\n후보 키(Candidate Key)는 유일성과 최소성을 모두 만족하는 키입니다. 슈퍼 키 중에서 최소성을 가진 키가 후보 키가 됩니다.\n기본 키(Primary Key)는 릴레이션에서 각 레코드를 유일하게 식별하는 주요 키입니다. 후보 키 중 선택되며, 반드시 유일하고 NOT NULL입니다.\n대체 키(Alternate Key)는 후보 키 중 기본 키는 제외한 나머지 모든 키입니다.\n외래 키(Foreign Key)는 다른 릴레이션의 기본 키를 참조하는 키입니다. 외래 키를 통해 테이블간 관계 표현이 가능합니다."
    },
    {
        "question": "DB에서 인덱스를 쓰는 이유에 대해 설명해 주세요.",
        "answer": "인덱스는 데이터를 빠르게 찾을 수 있는 수단으로서, 테이블에 대한 조회 속도를 높여주는 자료 구조입니다. 테이블의 특정 레코드 위치를 빠르게 알려주는 용도로 쓰게 됩니다.\n또한 인덱스를 사용하면 데이터가 정렬된 상태로 저장되므로 정렬된 결과를 빠르게 반환할 수 있습니다. 그리고 유니크 인덱스를 생성하여 중복된 값을 허용하지 않게 함으로써 데이터 무결성을 유지할 수 있습니다."
    },
    {
        "question": "hash 테이블 시간복잡도는 O(1)로 트리보다 빠른데 왜 트리를 사용할까요?",
        "answer": "hash 테이블은 일대일 대응 연산에만 특화되어 있어 범위 연산이 자주 사용되는 DB 검색에는 적합하지 않습니다. 더불어서 multi column index의 경우 전체 attributes에 대해 조회를 해야 합니다. 그리고 hash 충돌이 발생할 수 있기에 이를 위한 추가적인 작업이 필요할 수도 있습니다."
    },
    {
        "question": "데이터베이스에서 정규화의 목적을 설명해 주세요.",
        "answer": "가장 큰 목표는 테이블 간 중복된 데이터를 최소화하여 이상 현상을 방지하는 것입니다. 이를 통해 데이터 무결성을 유지하고, 불필요한 데이터를 최소화시킬 수 있습니다. 또한 테이블 구성을 논리적이고 직관적으로 할 수 있습니다. 마지막으로 데이터베이스 구조 확장이 용이해집니다."
    },
    {
        "question": "제 1정규화에 대해 설명해 주세요.",
        "answer": "테이블 컬럼이 하나의 값을 갖도록 테이블을 분리시키는 것을 말합니다. 어떤 릴레이션에 속한 모든 도메인이 원자값으로만 되어 있어야합니다."
    },
    {
        "question": "제 2정규화에 대해 설명해 주세요.",
        "answer": "제 1 정규형을 만족하고, 테이블의 모든 컬럼이 완전 함수적 종속을 만족하도록 분리시키는 것을 말합니다. 즉 기본 키에 종속적이지 않거나 기본 키 일부 컬럼들에만 종속적인 컬럼은 분리되어야 합니다."
    },
    {
        "question": "제 3정규화에 대해 설명해 주세요.",
        "answer": "제 2 정규형을 만족하고, 테이블에서 이행적 종속을 없애기 위해 분리시키는 것을 말합니다. 속성에 종속적인 속성은 분리되어야 합니다."
    },
    {
        "question": "이상 현상에 대해 설명해 주세요.",
        "answer": "이상 현상이란 릴레이션 조작 시 예기치 않게 발생하는 곤란한 현상입니다. 이상 현상의 종류로 삽입, 삭제, 갱신 이상이 있습니다.\n삽입 이상은 릴레이션에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들도 함께 삽입되는 현상입니다. 예를 들어 어떤 테이블에 직원의 정보를 저장하는데, 특정 부서에 아직 소속되지 않은 직원의 데이터를 삽입할 때 부서 정보가 없어 삽입이 불가능한 경우를 들 수 있습니다.\n삭제 이상은 릴레이션에서 한 레코드를 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는 연쇄가 발생하는 현상입니다. 예를 들어 부서 정보가 특정 직원에게만 연결돼 있고 그 직원이 퇴사하면서 부서 정보도 함께 삭제되는 경우가 있을 수 있습니다.\n갱신 이상은 릴레이션에서 레코드에 있는 속성값을 갱신할 때 일부 레코드의 정보만 갱신되어 정보의 모순이 생기는 현상입니다. 예를 들어 부서 정보가 여러 직원에게 중복되어 저장되어 있고, 부서 정보를 수정할 때 일부 직원만 수정되어 일관성이 깨질 수 있습니다."
    },
    {
        "question": "ERD에 대해 설명해 주세요.",
        "answer": "ERD(Entity Relationship Diagram)는 요구 분석 사항에서 얻은 엔티티와 속성들의 관계를 그림으로 나타낸 개체-관계 모델입니다.\n엔티티는 정의 가능한 사물 또는 개념을 의미하고 이는 곧 데이터베이스의 테이블이 됩니다.\n엔티티 속성은 개체가 가지고 있는 속성을 포함합니다. 이는 곧 테이블의 각 필드가 됩니다."
    },
    {
        "question": "ERD 엔티티 관계에 대해 설명해 주세요.",
        "answer": "엔티티 관계는 외래 키를 어떤 것으로 갖느냐에 따라 식별자/비식별자 관계로 먼저 구분할 수 있습니다. 부모 자식 관계에서 자식의 외래 키가 부모의 기본 키를 그대로 따르면 식별자 관계로 표현할 수 있습니다. 반면 부모의 기본 키를 외래 식별자로 참조해서 일반 속성으로 사용할 경우 비식별자 관계로 표현할 수 있습니다.\n한  개체에서 발생할 수 있는 횟수인 카디널리티에 따라서도 일대일/일대다/다대다 관계로 구분할 수 있습니다."
    },
    {
        "question": "데이터 무결성 세 가지에 대해 설명해 주세요.",
        "answer": "데이터 무결성은 데이터베이스에서 데이터의 정확성과 일관성을 유지하고 보장하는 중요한 개념입니다. 이 유형에는 개체 무결성, 참조 무결성, 도메인 무결성이 있습니다.\n개체 무결성은 모든 테이블이 기본 키를 가져야 하며 기본 키로 선택된 속성은 고유하여야 하고, NOT NULL임을 규정합니다.\n참조 무결성은 외래 키의 개념과 관련있으며 모든 외래 키 값은 기본 키 값을 참조함을 규정합니다.\n도메인 무결성은 데이터의 모든 열이 정의된 범위에서 선언되도록 규정합니다. (예시. 나이는 음수가 될 수 없음)"
    },
    {
        "question": "트랜잭션에 대해서 설명해 주세요.",
        "answer": "트랜잭션은 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위입니다. 트랜잭션은 ACID 특징을 갖고 있습니다. Atomicity, 원자성은 트랜잭션을 구성하는 연산 전체가 DB에 모두 반영되거나 혹은 취소되어야 하는 성질입니다. Consistency, 일관성은 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 후의 상태가 같아야 하는 성질입니다. Isolation, 독립성은 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때 서로의 연산에 끼어들 수 없는 성질입니다. Durability, 지속성은 트랜잭션이 성공적으로 완료되었으면 결과는 영구적으로 반영되어야 하는 특징입니다."
    },
    {
        "question": "트랜잭션 연산에 대해 설명해 주세요.",
        "answer": "트랜잭션 연산에는 Commit과 Rollback이 있으며 두 연산에 의해 원자성을 보장받습니다. Commit은 하나의 트랜잭션이 성공적으로 끝나고, DB가 일관성 있는 상태에 있거나 하나의 트랜잭션이 끝났을 때 사용하는 연산입니다. Rollback은 하나의 트랜잭션이 비정상적으로 종료되어 트랜잭션 원자성이 깨질 경우 처음부터 다시 시작하거나 부분적으로 연산을 취소하는 연산입니다."
    },
    {
        "question": "트랜잭션이 Isolation을 보장하는 방법에 대해 설명해 주세요.",
        "answer": "다른 트랜잭션이 현재의 데이터에 대한 무결성을 해치지 않기 위해 잠금을 설정하는 격리 수준을 정할 수 있습니다. 격리 수준은 여러 트랜잭션이 동시에 실행될 때 발생할 수 있는 문제를 제어하기 위한 메커니즘입니다.\n레벨 0의 격리 수준은 Read Uncommitted에 해당합니다. 트랜잭션이 처리 중이거나, 아직 Commit되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용합니다. 이는 DB의 일관성을 유지하는 것이 불가능하기 때문에 Dirty Read, Non-repeatable Read, Phantom Read 문제가 발생할 수 있습니다.\n레벨 1의 격리 수준은 Read Committed에 해당합니다. 트랜잭션이 수행되는 동안 다른 트랜잭션이 데이터에 접근할 수 없어 대기하게 됩니다. Commit이 이루어진 트랜잭션만 조회가 가능한 수준입니다. 따라서 Dirty Read는 발생하지 않지만 여전히 Non-repeatble Read는 발생할 수 있습니다.\n레벨 2의 격리 수준은 Repeatable Read에 해당합니다. 이는 다른 사용자가 트랜잭션 영역에 해당되는 데이터에 대해 수정을 불가능하게 합니다. 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장합니다. 따라서 Non-repeatble Read는 방지됩니다.\n마지막 Serializable은 다른 사용자가 트랜잭션 영역에 해당되는 데이터에 대한 수정, 입력을 불가능하게 합니다. 완벽한 읽기 일관성 모드를 제공하여 Phantom Read를 방지합니다."
    },
    {
        "question": "트랜잭션 격리 수준을 선택하는 기준에 대해 설명해 주세요.",
        "answer": "Read Uncommitted는 성능이 중요하고 데이터 일관성이 크게 중요하지 않은 경우에 사용될 수 있습니다.\nRead Committed는 대부분의 시스템에서 기본적으로 사용되며, 일반적인 요구 사항을 충족합니다.\nRepeatble Read 또는 Serializable은 데이터 일관성이 매우 중요하며, 동시에 여러 트랜잭션이 발생할 가능성이 높은 경우 선택됩니다.\n각 격리 수준은 일관성과 성능 간의 트레이드오프를 나타내며, 특정 상황에 맞게 선택되어야 합니다."
    },
    {
        "question": "RDB의 특징에 대해 설명해 주세요.",
        "answer": "RDB, 관계형 데이터베이스는 데이터가 하나 이상의 열과 행의 테이블에 저장되어 서로 다른 데이터 구조가 어떻게 관련되어 있는지 쉽게 파악하고 이해할 수 있도록 구성된 데이터 베이스입니다."
    },
    {
        "question": "NoSQL이 나오게 된 이유와 종류에 대해 설명해 주세요.",
        "answer": "웹의 성장에 따라 멀티미디어 데이터와 같은 비정형 데이터가 빠른 속도로 대량 생산되고 있습니다. 이런 환경에서 RDB를 적용하면, 데이터의 스키마가 이미 정해져 있어 속성을 자주 추가하고 조정하기에 적합하지 않습니다. 또한 관계를 맺고 있기 때문에 JOIN이 많은 복잡한 쿼리가 만들어질 수 있습니다.\n즉 대량의 비정형 데이터의 저장과 유연한 처리를 위해 새로운 대안으로 제시된 것이 NoSQL입니다.\nNoSQL 종류에는 대표적으로 MongoDB, Redis 등이 있습니다. MongoDB는 JSON을 통해 데이터에 접근할 수 있고, Document 기반의 DB입니다. 스키마를 정해 놓지 않고 데이터를 삽입할 수 있기 때문에 확장성이 뛰어납니다. Document를 생성할 때마다 고유한 ObjectID가 생성됩니다. Redis는 인메모리 DB이자 key-value 데이터 모델 기반의 DB입니다. 문자열, set, sorted set, hash, list 데이터를 지원하고, 높은 성능을 제공하며 데이터의 영속성을 옵션으로 지원합니다."
    },
    {
        "question": "Redis을 적용하면 적합한 경우에 대해 설명해 주세요.",
        "answer": "일반적인 DB가 하드 디스크나 SSD에 저장하는 것과는 달리 Redis는 RAM에 데이터를 저장합니다. 이는 디스크 스캐닝이 필요없어 매우 빠르다는 장점을 가집니다.\n데이터 구조가 간단하고 key-value 저장이 적합한 경우 Redis를 적용하기에 적합하다고 볼 수 있습니다. 복잡한 쿼리나 RDB의 JOIN이 필요 없는 간단한 구조에서 효과적으로 사용됩니다.\n이전에 검색하거나 계산한 것을 재사용하는 캐싱에 적용하면 빠르게 액세스할 수 있습니다. 이를 통해 반복적인 요청에 대한 응답 시간을 크게 단축할 수 있습니다.\n실시간 데이터 처리가 필요한 경우에도 적합합니다. 온라인 광고 노출, 게임 순위표와 같은 상황에서 Redis는 매우 빠른 응답 시간을 제공하여 실시간으로 데이터를 업데이트하고 조회하는 데에 적합합니다."
    },
    {
        "question": "RDB와 NoSQL을 비교해서 설명해 주세요.",
        "answer": "RDB와 NoSQL은 데이터베이스의 다른 형태로 특징과 용도에 따라 선택됩니다.\nRDB는 명확하게 정의된 스키마가 존재하고, 데이터 무결성을 보장할 수 있다는 장점이 있습니다. 이러한 특징때문에 덜 유연한 편이고, 관계를 맺고 있어서 조건에 따라 JOIN이 많은 복잡한 쿼리가 만들어질 수 있습니다.\nNoSQL은 스키마가 없어서 유연하여, 저장된 데이터를 쉽게 조정하고 새로운 필드를 추가하는 데 용이하다는 장점을 가집니다. 그러나 유연하다는 특징때문에 데이터 수정 시 모든 컬렉션에서 수행해야 하고, 데이터 중복을 계속 업데이트해야한다는 단점을 가지고 있습니다.\n따라서 관계를 맺고 있는 데이터가 자주 변경되거나, 데이터의 스키마가 변경될 여지가 적은 경우 RDB를 선택하는 것이 적합합니다. 반대로 데이터 구조가 변경될 가능성이 크고 데이터 변경에 비해 읽기, 삽입이 많은 경우 NoSQL을 선택하는 것이 적합합니다."
    },
    {
        "question": "Restful API에 대해 설명해주세요.",
        "answer": "Restful API는 두 컴퓨터 시스템이 인터넷을 통해 안전하게 정보를 전달하기 위해 사용되는 인터페이스입니다."
    },
    {
        "question": "프레임워크와 라이브러리 차이에 대해 설명해주세요.",
        "answer": "이 둘의 차이점은 제어 흐름에 대한 주도권이 누구에게/어디에 있는가에 있습니다."
    },
    {
        "question": "Call By Value와 Call By Reference의 차이에 대해 설명해주세요.",
        "answer": "Call By Value (값에 의한 호출)\n인자로 받은 값을 복사하여 처리하는 방식입니다.\nCall By Reference (참조에 의한 호출)\n인자로 받은 값의 주소를 참조하여 직접 저장해 값에 영향을 주는 방식입니다."
    },
    {
        "question": "CORS(교차 출처 리소스 공유, Cross-Origin Resource Sharing)에 대해 설명해주세요.",
        "answer": "CORS란 도메인이 서로 다른 2개의 사이트가 데이터를 주고 받을 때 발생하는 문제입니다."
    },
    {
        "question": "절차지향 프로그래밍과 객체지향 프로그래밍의 차이점에 대해 설명해주세요.",
        "answer": "절차지향 프로그래밍\n순차적인 처리를 중요시하는 프로그래밍 기법, 대표적인 언어로 C언어가 있습니다. 컴퓨터의 처리구조와 유사해 실행속도가 빠릅니다.\n\n\n객체지향 프로그래밍\n실제 세계의 사물들을 객체로 모델링하여 개발을 진행하는 프로그래밍 기법이며, 대표적인 언어로 Java가 있습니다.\n캡슐화, 상속, 다형성과 같은 기법을 이용할 수 있으며 절차지향 언어보다는 실행속도가 느립니다."
    },
    {
        "question": "동적 쿼리란 무엇이고 언제 동적 쿼리를 사용하나요?",
        "answer": "동적 쿼리란 실행시에 특정 조건이나 상황에 따라 쿼리 문장이 변경되어 실행되는 쿼리문을 말합니다."
    },
    {
        "question": "CSRF(Cross-Site Request Forgery)에 대해 설명하고, 이를 막기 위한 방법에 대해 설명해주세요.",
        "answer": "사이트 간 요청 위조의 약자로 웹 어플리케이션 취약점 중 하나입니다. 공격자가 의도한대로 사용자가 행동하게 하여 특정 웹 페이지를 보안에 취약하게 한다거나 수정, 삭제 등의 작업을 하게 만드는 공격 방법을 의미합니다."
    },
    {
        "question": "대칭키, 비대칭키 암호화 방식에 대해 설명해주세요.",
        "answer": "대칭키, 비대칭키는 양방향 암호화 방식입니다."
    },
    {
        "question": "TDD (Test-Driven-Development)의 개념에 대해 설명해주세요.",
        "answer": "TDD란 작은 단위의 테스트 케이스를 작성하고 그에 맞는 코드를 작성하여 테스트를 통과한 후에 상황에 맞게 리팩토링하는 테스트 주도 개발 방식을 말합니다."
    },
    {
        "question": "테스트 코드를 작성해야 하는 이유에 대해 아는대로 설명해주세요.",
        "answer": "예상하지 못한 오류에 대한 피드백을 위해\n실수를 줄여준다.\n좋은 설계로 작성되게끔 코드를 유도"
    },
    {
        "question": "MSA (Microservice Architecture)가 뭔지 설명해주세요.",
        "answer": "MSA는 1개의 시스템을 독립적으로 배포 가능한 각각의 서비스로 분할합니다. 각각의 서비스는 API를 통해 데이터를 주고 받으며 1개의 큰 서비스를 구성합니다."
    },
    {
        "question": "DDD (Domain-Driven-Design)에서 얘기하는 계층과 각각의 역할에 대해 설명해주세요.",
        "answer": "표현 계층 (Presentation layer)\n사용자의 요청에 대해 해석하고 응답하는 일을 책임지는 계층 (Controller)\n응용 계층 (Application layer)\n비즈니스 로직을 정의하고 정상적으로 수행될 수 있도록 도메인 계층과 인프라스트럭처 계층을 연결해주는 역할을 하는 계층 (Service)\n도메인 계층 (Domain layer)\n비즈니스 규칙, 정보에 대한 실질적인 도메인에 대한 정보를 가지고 있으며 이 모든 것을 책임지는 계층 (Entity)\n인프라스트럭처 계층 (Infrastructure layer)\n외부와의 통신을 담당하는 계층 (Repository)"
    },
    {
        "question": "프로세스와 쓰레드의 차이에 대해 설명해주세요.",
        "answer": "프로세스는 실행 중인 프로그램을 말하며, 완벽히 독립적이기 때문에 메모리영역(Code, Data, Heap, Stack)을 다른 프로세스와 공유하지 않습니다. 프로세스는 최소 1개의 쓰레드(메인 쓰레드)를 가지고 있습니다."
    },
    {
        "question": "데드락에 대해 설명해주세요.",
        "answer": "둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 상황을 말합니다.\n예를 들어, 자원 A를 가진 프로세스 P1과 자원 B를 가진 프로세스 P2가 있을 때, P1은 자원 B를 필요로 하고 P2는 자원 A를 필요로 한다면 두 프로세스는 서로 자원을 얻기 위해 무한정 기다리게 됩니다."
    },
    {
        "question": "멀티 프로세스와 멀티 쓰레드의 특징에 대해 설명해주세요.",
        "answer": "멀티 프로세스는 하나의 프로세스가 죽어도 다른 프로세스에 영향을 끼치지 않고 계속 실행된다는 장점이 있지만 멀티 쓰레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 있습니다."
    },
    {
        "question": "멀티 쓰레드의 동시성과 병렬성을 설명해주세요.",
        "answer": "동시성은 멀티 작업을 위해 싱글 코어에서 여러 개의 쓰레드가 번갈아 실행하는 것을 말합니다. (동시에 실행하는 것처럼 보이지만 사실은 번갈아가며 실행하고 있는 것)"
    },
    {
        "question": "멀티 쓰레드 환경에서의 주의사항을 설명해주세요.",
        "answer": "다수의 쓰레드가 공유 데이터에 동시에 접근하는 경우에 상호배제 또는 동기화 기법을 통해 동시성 문제 또는 교착상태에 빠지지 않도록 주의해야합니다."
    },
    {
        "question": "컨텍스트 스위칭(Context Switching)이 무엇인지 설명해주세요.",
        "answer": "멀티 프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값(Context)을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값(Context)을 교체하는 작업을 말합니다."
    },
    {
        "question": "선점형 스케줄링과 비선점형 스케줄링의 차이를 설명해주세요.",
        "answer": "선점형 스케줄링은 실행되고 있는 프로세스나 스레드를 강제로 중단시키고 다른 프로세스를 실행시키는 것을 말합니다.\n비선점형 스케줄링은 그 반대로, 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없는 것을 의미합니다."
    },
    {
        "question": "콘보이 현상(convoy effect)이 무엇이고, 콘보이 현상이 발생되고 있는 CPU 스케줄러 알고리즘은 무엇인지 설명해주세요.",
        "answer": "콘보이 현상이란 작업 시간이 긴 프로세스가 먼저 큐에 도착해서 다른 프로세스들의 실행 시간이 전부 늦춰져 효율성을 떨어뜨리는 현상을 말합니다."
    },
    {
        "question": "동기와 비동기의 차이에 대해 설명해주세요.",
        "answer": "동기는 순차적, 직렬적으로 테스크를 수행하고, 비동기는 병렬적으로 테스크를 수행합니다."
    },
    {
        "question": "임계 영역(Critical Section)에 대해 설명해주세요.",
        "answer": "임계 영역이란 프로세스간에 공유자원을 접근하는데 있어 문제가 발생하지 않도록 한번에 하나의 프로세스만 이용하게끔 보장해줘야 하는 영역을 말합니다."
    },
    {
        "question": "뮤텍스(Mutex)와 세마포어(Semaphore)의 차이에 대해 설명해주세요.",
        "answer": "공유된 자원에 여러개의 프로세스가 동시에 접근하게 되면 임계 영역(Critical Section) 문제가 발생할 수 있고, 이를 해결 하기 위해 데이터를 한번에 하나의 프로세스만 접근할 수 있도록 제한을 두는 동기화 방식을 취해야합니다.\n동기화 도구에는 대표적으로 뮤텍스와 세마포어가 있습니다."
    },
    {
        "question": "페이지 교체 알고리즘에 대해 설명해주세요.",
        "answer": "페이징 기법으로 메모리를 관리하는 운영체제에서 필요한 페이지가 주기억장치에 적재되지 않았을 때 (페이지 부재시) 어떤 페이지 프레임을 선택해 교체할 것인지 결정하는 방법을 페이지 교체 알고리즘이라고 합니다."
    },
    {
        "question": "동적 계획법(DP, Dynamic Programming)에 대해 설명해주세요.",
        "answer": "주어진 문제를 풀기 위해, 문제를 여러 개의 하위문제로 나누어 푸는 방법을 말합니다.\n동적 계획법에서는 어떤 부분 문제가 다른 문제들을 해결하는데 사용될 수 있어, 답을 여러 번 계산하는 대신 한번만 계산하고\n그 결과를 재활용하는 메모이제이션(Memoization)기법으로 속도를 향상시킬 수 있습니다."
    },
    {
        "question": "동적 계획법(DP, Dynamic Programming)이 갖는 2가지 조건은 무엇인가요?",
        "answer": "중복되는 부분(작은) 문제\n중복되는 부분 문제는 나눠진 부분 문제가 중복되는 경우로, 메모이제이션 기법을 통해 중복 계산을 없앱니다.\n\n\n최적 부분 구조\n최적 부분 구조를 가진다는 것은 전체 문제의 최적해가 부분 문제의 최적해들로써 구성된다는 것입니다."
    },
    {
        "question": "버블 정렬(Bubble Sort)에 대해 설명해주세요.",
        "answer": "버블 정렬은 서로 인접한 두 원소를 비교해서 정렬하는 알고리즘입니다. 시간복잡도는 O(n^2) 입니다."
    },
    {
        "question": "선택 정렬(Selection Sort)에 대해 설명해주세요.",
        "answer": "선택 정렬은 첫 번째 값을 두 번째 값부터 마지막 값까지 차례대로 비교하여 최솟값을 찾아 첫 번째에 놓고, 두 번째 값을 세번째 값부터 마지막 값까지 비교해 최솟값을 찾아 두번째 위치에 놓는 과정을 반복해 정렬하는 알고리즘입니다. 시간복잡도는 O(n^2)입니다."
    },
    {
        "question": "삽입 정렬(Insertion Sort)에 대해 설명해주세요.",
        "answer": "삽입 정렬은 두번째 값부터 시작해 그 앞에 존재하는 원소들과 비교해서 삽입할 위치를 찾아 삽입하는 정렬 알고리즘입니다. 평균 시간복잡도는 O(n^2)이며, BestCase의 경우 O(n)까지 높아질 수 있습니다."
    },
    {
        "question": "힙 정렬(Heap Sort)에 대해 설명해주세요.",
        "answer": "힙 정렬은 주어진 데이터를 힙 자료구조로 만들어 최댓값 또는 최솟값부터 하나씩 꺼내서 정렬하는 알고리즘 입니다. 시간 복잡도는 O(nlogn)입니다."
    },
    {
        "question": "병합 정렬(Merge Sort)에 대해 설명해주세요.",
        "answer": "병합 정렬은 주어진 배열을 크기가 1인 배열로 분할하고 합병하면서 정렬을 진행하는 분할/정복 알고리즘입니다. 시간 복잡도는 O(nlogn)입니다."
    },
    {
        "question": "퀵 정렬(Quick Sort)에 대해 설명해주세요.",
        "answer": "퀵 정렬은 빠른 정렬 속도를 자랑하는 분할/정복 알고리즘 중 하나로 피봇을 설정하고 피봇보다 큰 값과 작은 값으로 분할해 정렬합니다. 병합 정렬과 다르게 리스트를 비균등하게 분할합니다.\n시간 복잡도는 O(nlogn)이며 worst case의 경우 O(n^2)까지 나빠질 수 있습니다."
    },
    {
        "question": "Big-O 표기법의 시간 복잡도 크기 순서를 말해주세요.",
        "answer": "O(1) < O(log n) < O(n) < O(nlog n) < O(n^2) < O(2^n) < O(n!)"
    },
    {
        "question": "허프만 코딩에 대해 설명해주세요.",
        "answer": "허프만 코딩은 문자의 빈도수를 가지고 압축하는 과정을 말하며, 접두부 코드와 최적 코드를 사용합니다."
    },
    {
        "question": "재귀 알고리즘에 대해 설명해주세요.",
        "answer": "재귀 알고리즘이란 함수 내부에서 함수가 자기 자신을 호출하여 문제를 해결하는 알고리즘입니다.\n자기 자신을 계속해서 호출해서 끝없이 반복하게 되므로 반복을 중단할 조건이 반드시 필요합니다."
    },
    {
        "question": "피보나치 수열의 N번째 값을 구하는 메소드에 대해 각각 재귀와 반복문으로 손코딩(또는 수도코딩) 해주세요.",
        "answer": "#반복문\nn = int(input())\ndp = [0,1]\nfor i in range(2,n+1):\n    dp.append(dp[i-1]+dp[i-2])\nprint(dp[n])\n\n#재귀\nn = int(input())\n\ndef fib(x):\n    if x==0:\n        return 0\n    elif x==1:\n        return 1\n    else:\n        return fib(x-1)+fib(x-2)\nprint(fib(n))"
    },
    {
        "question": "팩토리얼의 N번째 값을 구하는 메소드에 대해 각각 재귀와 반복문으로 손코딩(또는 수도코딩) 해주세요.",
        "answer": "#반복문\nn = int(input())\ndp = [1,1]\n\nfor i in range(2,n+1):\n    dp.append(dp[i-1]*i)\n    \nprint(dp[n])\n\n#재귀\nn = int(input())\n\ndef fac(x):\n    if x==1:\n        return 1\n    else:\n        return fac(x-1)*x\n    \nprint(fac(n))"
    },
    {
        "question": "📌  웹 통신의 큰 흐름: https://www.google.com/ 을 접속할 때 일어나는 일",
        "answer": "1) Host가 google.com을 검색하면 OS에서 NIC(network Interface Card, 이거 하나 당 IP하나씩 받을 수 있음)를 통해\n요청을 보내야 한다. Host는 google의 IP주소를 알아야 한다.\n \n2) 내가 IP주소를 아는지 모르는지 판단하기 위해 hosts와 DNS cache에서 mapping 정보를 확인한다.(DNS Lookup)\n \n3) 2)에서 없으면 DNS서버로 요청을 보내서 응답을 받는다. (공유기 / 라우터가 DNS를 알고있음. 인터넷 망을 통해 DNS서버로 요청을 한다.)\n \n4) 그 IP주소로 http request를 보내고 응답을 받는다. (해당 IP로 가는 경로는 중간중간의 Router들의 Routing Table에 저장되어있다.)\n \n\n📌  OSI 7계층에 대해 설명해주세요\n1) 1계층 : 물리계층(Physical Layer)\n- 데이터를 전기 신호로 바꿔서 와이어에 실어주는 계층\n-  장비 : 리피터(전기신호를 증폭), 허브\n- 단위 :Bit \n \n2) 2계층 : 데이터링크 계층(Data Link Layer)\n- P2P 간 신뢰성있는 전송을 보장하기 위한 계층으로 CRC 기반의 오류 제어와 흐름 제어가 필요\n- 주소값은 MAC Address를 물리적으로 할당받으며, NIC(=LAN카드)가 만들어질때부터 고유 일련번호가 있다.(사설 IP는 중복 가능)\n- 단위 : Frame\n- 장비 : Bridge, L2 Switch(중요)\n- 프로토콜 : 이더넷(중요), HDLC\n \n3) 3계층 : 네트워크 계층(Network Layer)\n- IP주소 기반으로 경로를 찾아주는 계층\n- 라우터를 통해 이동할 경로를 선택하여 IP 주소를 지정하고, 해당 경로에 따라 패킷을 전달\n- 라우팅, 흐름 제어, 오류 제어, 세그멘테이션 등을 수행\n- 단위 : Packet\n- 프로토콜 :  IP, RIP, ARP, ICMP\n- 장비 : Router(L3 Switch)\n \n4) 4계층 : 전송 계층(Transport Layer)\n- TCP, UDP 등의 프로토콜을 통해 통신을 활성화\n- 포트를 열어두고, 프로그램들이 전송할 수 있도록 제공\n- 오류검출 및 복구, 흐름 제어, 중복검사 등 수행\n- Port기반 데이터 세그먼트 전송\n- 단위 : Segment(TCP) / Datagram(UDP)\n- 프로토콜 : TCP / IP\n- 장비 : 게이트웨이 \n \n5) 5계층 : 세션 계층(Session Layer)\n- TCP/IP 세션을 만들고 없애는 책임을 지니고 있다.\n- 세션 설정, 유지, 종료, 전송 중단시 복구 등의 기능이 있다.\n- Ex) API, Socket\n \n6) 6계층 : 표현 계층(Presentation) 계층\n- 데이터 표현에 대한 독립성을 제공하고 암호화하는 역할\n- 파이\n- Ex) JPEG, MPEG 등\n사용자의 명령어를 완성 및 결과 표현. 포장/압축/암호화\n \n\n7) 응용(Application) 계층\n- 일반적인 응용 서비스를 수행한다.\n- 사용자 인터페이스, 전자우편, 데이터베이스 관리 등의 서비스를 제공한다.\n- HTTP, FTP, SMTP, IMAP, Telnet 등\n\n \n\n \n📌  TCP와 UDP의 차이점에 대해서 설명해보세요.\n\n- TCP는 Connection Oriented Protocol(연결 지향형 프로토콜)로, 신뢰성있는 데이터전송을 보장합니다. \n- UDP는 Connectionless Protocol로 빠르지만 데이터의 유실 가능성이 존재하는 걸로 알고있습니다. \n- 그래서 일반적인 경우, TCP를 사용하고 데이터가 유실되더라도 실시간성이 중요한 스트리밍방송, 통화 등에서는 UDP를 사용하는것으로 알고 있습니다.\n \n\n \n \n1) TCP 특징\n\n연결형 서비스로 가상 회선 방식을 제공한다.\n3-way handshaking과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다.\n흐름 제어 및 혼잡 제어.\n높은 신뢰성을 보장한다.\nUDP보다 속도가 느리다.\n전이중(Full-Duplex), 점대점(Point to Point) 방식\n\n2) TCP 서버 특징 \n\n서버소켓은 연결만을 담당한다.\n연결과정에서 반환된 클라이언트 소켓은 데이터의 송수신에 사용된다형 서비스로 가상 회선 방식을 제공한다.\n서버와 클라이언트는 1대1로 연결된다.\n스트림 전송으로 전송 데이터의 크기가 무제한이다.\n패킷에 대한 응답을 해야하기 때문에(시간 지연, CPU 소모) 성능이 낮다.\nStreaming 서비스에 불리하다.(손실된 경우 재전송 요청을 하므로)\n\n \n \n\n \n \n\n \n\n3) UDP 특징\n\n비연결형 서비스로 데이터그램 방식을 제공한다\n정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.\nUDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.\n신뢰성이 낮다\nTCP보다 속도가 빠르다\n\n4) UDP 서버 특징 \n\nUDP에는 연결 자체가 없어서(connect 함수 불필요) 서버 소켓과 클라이언트 소켓의 구분이 없다.\n소켓 대신 IP를 기반으로 데이터를 전송한다.\n서버와 클라이언트는 1대1, 1대N, N대M 등으로 연결될 수 있다.\n데이터그램(메세지) 단위로 전송되며 그 크기는 65535바이트로, 크기가 초과하면 잘라서 보낸다.\n흐름제어(flow control)가 없어서 패킷이 제대로 전송되었는지, 오류가 없는지 확인할 수 없다.\n파일 전송과 같은 신뢰성이 필요한 서비스보다 성능이 중요시 되는 경우에 사용된다.\n\n5) UDP는 항상 신뢰성을 보장하지 않나요?\n- UDP도 신뢰성을 UDP자체에서 보장하지 않는 것 뿐이지, 개발자가 직접 신뢰성을 보장하도록 할 수 있습니다. HTTP/3의 경우,  UDP 기반의 QUIC이라는 프로토콜을 사용합니다. UDP 자체는 신뢰성을 보장하지 않지만, 추가적인 정의를 통해 신뢰성을 보장받을 수 있습니다.\n \n\n\n\n프로토콜 종류\nTCP\nUDP\n\n\n연결 방식\n연결형 서비스\n비연결형 서비스\n\n\n패킷 교환 방식\n가상 회선 방식\n데이터그램 방식\n\n\n전송 순서\n전송 순서 보장\n전송 순서가 바뀔 수 있음\n\n\n수신 여부 확인\n수신 여부를 확인함\n수신 여부를 확인하지 않음\n\n\n통신 방식\n1:1 통신\n1:1 OR 1:N OR N:N 통신\n\n\n신뢰성\n높다.\n낮다.\n\n\n속도\n느리다.\n빠르다.\n\n\n\n \n\n📌  TCP의 신뢰성을 보장하는 방법을 설명해보세요.\n1) 패킷(Packet)이란? \n-  데이터를 여러개의 조각으로 나누어 전송 할 때의 조각 단위\n \n2) TCP는 패킷을 어떻게 추적 및 관리하는가? \n- 각 패킷에 번호를 부여한다.\n3) 흐름 제어란?\n- 송신측의 전송량 > 수신측의 수신량 일 경우 발생할 문제를 예방하기 위한 제어\n-  송신측의 패킷 전송량을 제어\n \n ▶ Stop and Wait (정지 - 대기) \n\n매번 전송한 패킷에 대한 확인 응답을 받아야 그 다음 패킷을 전송할 수 있다.\nGive & Take \n\n ▶  Sliding Window(슬라이딩 윈도우) \n\n수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답 없이 세그먼트를 전송한다. \n윈도우 : 송신, 수신 스테이션 양쪽에서 만들어진 버퍼의 크기  \n송신측에서는 Ack 프레임을 수신하지 않더라도 여러 개의 프레임을 연속적으로 전송할 수 있다\n송신측에서 0,1,2,3,4,5,6을 보낼 수 있는 프레임을 가지고 있고 데이터 0,1을 전송했다고 가정하면 슬라이딩 윈도우 구조는 2,3,4,5,6처럼 변하게 된다. \n이때, 만약 수신측으로부터 ACK라는 프레임을 받게 된다면 송신측은 이전에 보낸 데이터 0,1을 수신측에서 정상적으로 받았음을 알게 되고 송신측의 슬라이딩 윈도우는 ACK 프레임에 따른 프레임의 수만큼 오른쪽으로 경계가 확장된다. \n\n \n4) 오류제어란?\n\n오류 검출과 재전송\n\n▶ ARQ (Automatic Repeat Request)\n- TCP는 기본적으로 재전송 기반의 오류 제어를 사용(오류가 발생 시, 송신 -> 수신으로 데이터 재전송) \n- 하지만 실제로 수 많은 데이터를 주고 받아야 하는 네트워크 상황에서 이러한 재전송 방식은 그 자체로 비효율적이기 때문에 이러한 재전송을 최대한 적게하는 여러 방식으로 TCP는 오류를 제어\n \n ▶  Stop and Wait ARQ (Automatic Repeat Request)\n\n송신측에서 1개의 프레임을 송신하고, 수신측에서 수신된 프레임의 에러 유무 판단에 따라 ACK or NAK(Negative Acknowledgement)를 보내는 방식\n식별을 위해 데이터 프레임과 ACK 프레임은 각각 0,1 번호를 번갈아가며 부여한다. \n수신측이 데이터를 받지 못했을 경우, NAK를 보내고 NAK를 받은 송신측은 데이터를 재전송한다. \n만약, 데이터나 ACK가 분실되었을 경우 일정 간격의 시간을 두고 타임아웃이 되면, 송신측은 데이터를 재전송한다. \n\n▶ Go-Back-n ARQ(슬라이딩 윈도우) \n\n전송된 프레임이 손상되거나 분실된 경우 , ACK 패킷의 손실로 인한 TIME_OUT이 발생된 경우, 확인된 마지막 프레임 이후로 모든 프레임을 재전송\n슬라이딩 윈도우는 연속적인 프레임 전송 기법으로 전송측은 전송된 프레임의 복사본을 가지고 있어야 하며, ACK와 NAK 모두 각각 구별해야 한다. \nACK : 다음 프레임을 전송 \nNAK : 손상된 프레임 자체 번호를 반환\n\n▶  SR(Selective-Reject) ARQ\n\nSR ARQ는 손상된, 손실된 프레임만 재전송한다 \n그렇기 때문에 별도의 데이터 재정렬을 수행하야 하며, 별도의 버퍼를 필요로 한다\n수신측에 버퍼를 두어 받은 데이터의 정렬이 필요\n\n\n5) 혼잡제어란?\n\n송신측의 데이터 전달과 네트워크의 데이터 처리 속도를 해결하기 위한 기법\n 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 제어하는 것이 혼잡 제어의 개념이다. \n\n▶   AIMD (Addtive Increase Multicative Decrease) \n\n합 증가 / 곱 감소 알고리즘\n처음에 패킷 하나를 보내는 것으로 시작하여 전송한 패킷이 문제 없이 도착한다면 Window Size를 1씩 증가시키며 전송하는 방법. 만약, 패킷 전송을 실패하거나 TIME_OUT이 발생하면 Window Size를 절반으로 감소시킨다. \n문제점 : 초기 네트워크의 높은 대역폭을 사용하지 못하고 네트워크가 혼잡해지는 상황을 미리 감지하지 못하여 혼잡해지고 나서야 대역폭을 줄이는 방식이다. \n\n▶ Slow Start \n\nSlow Start는 AIMD와 마찬가지로 패킷을 하나씩 보내는 것부터 시작한다. 이 방식은 패킷이 문제 없이 도착하면 ACK 패킷마다 Window Size를 1씩 늘린다. 즉, 한 주기가 지나면 Window Size는 2배가 된다 \n혼잡 현상이 발생하면 Window Size를 1로 떨어뜨린다 \n\n\n\n미리 정해진 임계값(threshold)에 도달할 때까지 윈도우의 크기를 2배씩 증가시킨다. \n전송되는 데이터의 크기가 임계 값에 도달하면 혼잡 회피 단계로 넘어간다 \n\n\n[혼잡 회피(Congestion Avoidance)] \n\n윈도우의 크기가 임계 값에 도달한 이후에는 데이터의 손실이 발생할 확률이 높다 \n따라서 이를 회피하기 위해 윈도우 크기를 선형적으로 1씩 증가시키는 방법\n\n[빠른 회복(Fast Recovery)]\n\n혼잡한 상태가 되면 Window Size를 1로 줄이지 않고 절반으로 줄이고 선형 증가시키는 방법\n빠른 회복 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작\n\n[빠른 재전송(Fast Retransmit)]\n\n수신측에서 패킷을 받을 때 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보낸다. 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보낸다. 따라서 중간에 패킷 하나가 손실되면 송신측에서는 순번이 중복된 ACK 패킷을 받게 된다. 이것을 감지하면 문제가 되는 순번의 패킷을 재전송할 수 있다. \n빠른 재전송은 중복된 순번의 패킷을 3개(3 ACK) 받으면 재전송한다. 그리고 이러한 현상이 일어나는 것은 약간의 혼잡이 발생한 것으로 간주하여 Window Size를 절반으로 줄인다. \n\n출처: https://rok93.tistory.com/entry/네트워크-TCP-흐름제어혼잡제어 [티끌모아 로키산맥 🏔]\n\n\n📌  HTTP를 버전 별로 설명해주세요\n\n1) HTTP 1.0\n - 단기 커넥션(shrot-live connections) : 요청 날릴때마다 커넥션 맺고 끊어짐\n- Request를 날릴 때마다 Connection을 새로 생성해야 함\n- Data를 압축해서 전달 가능하도록 하여 전달하는 Data 양이 감소\n2) HTTP 1.1\n- 지속 커넥션(Persistent connection) : 커넥션 재사용 가능\n- HTTP 파이프라이닝(Pipelining) : Request를 미리 여러 개 서버에 날릴 수 있음 (이전엔 리퀘스트 하나보내고, Response 받고, 그 다음 request 보내는 방식이었는데, 파이프라이닝 방식에서는 Request를 연속적으로 보내놓고 Reponse를 받는 방식)\n- 단점 : Head Of Line Blocking  => 요청한 Request에 문제가 생겨 응답이 늦어지면 그 다음 Request의 응답들도 같이 늦어짐\n \n3) HTTP 2.0\n- Multiplexing : 프레임 단위로 나눠서 전송 관리 가능하게 됨 (다수의 요청과 응답이 가능한 구조)\n- 데이터 전송 방식 : 바이너리로 인코딩하여 전송\n- ServerPush 사용 : 브라우저에서 필요한 리소스들을 서버가 알아서 찾아다가 내려주는 것\n\n\n캐싱되지 않은 리소스를 받아올 때\n페이지에서 필요한 리소스가 페이지를 내려주는 서버에 있을 때\n\n\n📌  HTTP와 HTTPS의 차이점에 대해 설명해주세요.\n- HTTPS(Hypertext Transfer Protocol Secure)\n- 둘 다 웹 통신 프로토콜이지만, HTTPS는 HTTP의 기능에 TLS(Transport Layer Security)  혹은 SSL(Secure Sockets Layer)을 사용하여 암호화된 버전입니다. 일반적으로 보안이 중요한 통신에서는 HTTPS를 사용하는걸로 알고있고, HTTP는 80 port, HTTPS는 443 port를 사용하는 것으로 알고 있습니다. \n \n1) SSL 인증서란?\n- SSL 프로토콜에 사용되는 인증서\n▶ 역할\n\n클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보증한다.\n통신에 사용할 공개키를 클라이언트에 전달한다.\n\n▶ 포함 내용\n\n서비스 정보(CA 정보, 도메인 등)\n서버 측 공개키\n\n▶  CA(Certificate Authority)\n\n위 인증서를 발급해주는 제 3자이다.\n브라우저는 신뢰할 수 있는 CA(공인 CA)들과 해당 CA의 공개키를 알고있다.\n\n\n2) SSL 동작원리는?\n▶  대칭키 방식\n\n암호화와 복호화를 동일한 하나의 키(대칭키)로 하는 방식이다.\n암호 통신을 하기 위해선 대칭키를 주고 받아야 하기 때문에 키가 유출될 가능성이 있다.\n\n▶  공개키 방식( = 비대칭키 방식)\n\n두개의 키(공개키, 비밀키)로 암호화 및 복호화하는 방식.\n공개키로 암호화 -> 비밀키로 복호화 / 비밀키로 암호화 -> 공개키로 복호화\n\n▶  SSL은 대칭키, 공개키를 함께 사용한다\n\n공개키 방식은 보안이 뛰어나지만 암호화/복호화에 컴퓨팅파워가 많이 든다.\n따라서 데이터 전달에는 대칭키를 쓰고, 그 대칭키를 교환할 때는 공개키 사용한다.\n\n\n3) SSL HandShake 과정은?\n \n\n1. Client -> Server(Client hello) \n\n클라이언트가 생성한 랜덤 데이터\n클라이언트가 지원하는 암호화 방식\nSession Id (이미 SSL handshake를 한번 완료했다면 기존 session 재활용)\n\n2. Server -> Client(Server hello)\n\n서버가 생성한 랜덤 데이터\n서버가 선택한 암호화 방식\nCA의 비밀키로 암호화 된 SSL 인증서\n\n3. Client -> Server\n\n클라이언트는 먼저 인증서를 발행한 CA를 신뢰할 수 있는지 판단한다 (갖고 있는 CA 리스트와 비교).\n진짜 그 CA가 발행한 인증서가 맞는지 확인한다.\n\n기존에 갖고 있는 CA의 공개키를 사용해 인증서를 복호화 한다.\n복호화에 성공한다면, 신뢰 할 수 있는 CA가 보증한 서버임을 확신할 수 있다.\n공개키 방식을 거꾸로 사용해 Authentication에 활용했다고 할 수 있다.\n\n\n이후 Client hello 의 랜덤 데이터와 Server hello 의 랜덤 데이터를 조합하여 pre master key 생성한다.\npre master key를 암호화(인증서에 포함된 서버측 공개키 사용)하여 서버에 전송한다.\n\n4. Pre master key를 session key로 변환\n\n서버는 자신의 비밀키로 전달받은 pre master key를 복호화한다.\n클라이언트와 서버 모두 일련의 과정을 거쳐 세션 키를 획득한다.( pre master key -> master key -> session key )\n이후 세션 키를 대칭키로 사용해 데이터를 암호화 하여 클라이언트-서버 통신이 이루어진다.\n\n5. Handshake 종료\n \nhttps://velog.io/@shkilo/HTTPS%EC%99%80-SSLTLS-%EC%A0%95%EB%A6%AC\n\nhttps://jeongm1n.tistory.com/entry/%EC%BB%B4%ED%93%A8%ED%84%B0%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-SSL-%ED%86%B5%EC%8B%A0-%EA%B3%BC%EC%A0%95\n\n \n\n \n\n\n📌 HTTP Method와 각각이 사용되는 경우에 대해서 설명해주세요.\n\n\n\n\n\n종류\n기능\n\n\nGET\n데이터 조회\n\n\nPOST\n요청 데이터 처리(보통 데이터 등록 사용)\n\n\nPUT\n데이터 변경 (해당 데이터가 없으면 생성)\n\n\nPATCH\n일부 데이터만 변경\n\n\nDELETE\n데이터 삭제\n\n\n\n \n\n📌 GET과 POST의 차이점에 대해 설명해주세요. \n- GET은 데이터를 조회하기 위해 사용되는 방식으로 데이터를 헤더에 추가하여 전송하는 방식입니다.\n URL에 데이터가 노출되므로 보안적으로 중요한 데이터를 포함해서는 안됩니다.\n \n- POST는 데이터를 추가, 수정하기 위해 사용되는 방식으로 데이터를 바디에 추가하여 전송하는 방식입니다.\n완전히 안전하다는 것은 아니지만 URL에 데이터가 노출되지 않아 GET 보다는 안전합니다.\n \n\n \n📌 쿠키(Cookie)와 세션(Session)의 차이점에 대해 설명해주세요.\n- 쿠키는 웹서버와 클라이언트가 통신할 때, 클라이언트쪽에서 가지고 있는 정보이고, 세션은 서버쪽에서 가지고 있는 정보입니다.\n- 쿠키는 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일입니다. HTTP에서 클라이언트의 상태 정보를 PC에 저장했다가 필요시 정보를 참조하거나 재사용할 수 있습니다.\n \n- 세션은 일정 시간동안 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 유지시키는 기술입니다. 즉, 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션이라고 합니다.\n \n\n\n\n \n쿠키(Cookie)\n세션(Session)\n\n\n저장 위치\n클라이언트(=접속자 PC)\n웹 서버\n\n\n저장 형식\ntext\nObject\n\n\n만료 시점\n쿠키 저장시 설정(브라우저가 종료되도, 만료시점이 지나지 않으면 삭제되지 않음)\n브라우저 종료시 삭제(기간 지정 가능)\n\n\n사용하는 자원(리소스)\n클라이언트 리소스\n웹 서버 리소스\n\n\n용량 제한\n총 300개하나의 도메인 당 20개하나의 쿠키 당 4KB(=4096byte)\n서버가 허용하는 한 용량제한 없음\n\n\n속도\n세션보다 빠름\n쿠키보다 느림\n\n\n보안\n세션보다 안좋음\n쿠키보다 좋음\n\n\n\n쿠키의 동작 순서\n\n클라이언트가 페이지를 요청한다. (사용자가 웹사이트에 접근)\n웹 서버는 쿠키를 생성한다.\n생성한 쿠키에 정보를 담아 HTTP 화면을 돌려줄 때, 같이 클라이언트에게 돌려준다.\n넘겨받은 쿠키는 클라이언트가 가지고 있다가(로컬 PC에 저장) 다시 서버에 요청할 때 요청과 함께 쿠키를 전송한다.\n동일 사이트 재방문 시 클라이언트의 PC에 해당 쿠키가 있는 경우, 요청 페이지와 함께 쿠키를 전송한다.\n\n\n세션의 동작 순서\n\n클라이언트가 페이지에 요청한다. (사용자가 웹사이트에 접근)\n서버는 접근한 클라이언트의 Request-Header 필드인 Cookie를 확인하여, 클라이언트가 해당 session-id를 보냈는지 확인한다.\nsession-id가 존재하지 않는다면 서버는 session-id를 생성해 클라이언트에게 돌려준다.\n서버에서 클라이언트로 돌려준 session-id를 쿠키를 사용해 서버에 저장한다.\n클라이언트는 재접속 시, 이 쿠키를 이용해 session-id 값을 서버에 전달\n\n\n사용 예시\n\n화면을 이동해도 로그인이 풀리지 않고 로그아웃하기 전까지 유지\n\n\n\n\n📌 세션 기반 인증과 토큰 기반 인증의 차이에 대해 얘기해주세요. \n\n- 세션 기반 인증은 클라이언트로부터 요청을 받으면 클라이언트의 상태 정보를 저장하므로 Stateful한 구조를 가지고,\n- 토큰 기반 인증은 상태 정보를 서버에 저장하지 않으므로 Stateless한 구조를 가집니다.\n \n- Stateful한 세션 기반의 인증 방식을 사용하게 된다면, 서버에 세션을 저장해야 하므로 서버에 부담이 상대적으로 더 가며 확장성이 낮습니다. 또한 해커가 훔친 쿠키를 이용해 요청을 보내면 서버는 올바른 사용자가 보낸 요청인지 알 수 없습니다. (세션 하이재킹 공격)\n \n- 따라서 단일 도메인이라면 세션 기반 인증을 사용하고, 아니라면 토큰 기반 인증을 사용하는 것이 적합하다고 생각합니다. 세션을 관리할 때 사용되는 쿠키는 단일 도메인 및 서브 도메인에서만 작동하도록 설계되어 있기 때문에 여러 도메인에서 관리하는 것은 어렵습니다. (CORS 문제) \n \n- CORS는 대개 로컬에서 API 서버에 요청을 보낼 때 흔하게 발생합니다. 서로 다른 도메인간에 자원을 공유하는 것을 뜻합니다. 대부분의 브라우저에서는 이를 기본적으로 차단하며, 서버측에서 헤더를 통해서 사용가능한 자원을 알려줍니다.\n- preflight request는 실제 요청을 보내도 안전한지 판단하기 위해 사전에 보내는 요청입니다. OPTIONS 메서드로 요청하며 CORS를 허용하는지 확인합니다. CORS가 허용된 웹서버라면 사용 가능한 리소스를 헤더에 담아 응답합니다.\n\n📌 TCP 3,4 way handshake에 대해 설명해주세요. \n\n\n\n\n\n📌 Connection Timeout과 Read Timeout의 차이에 대해 설명해주세요\n- Connection Timeout은 초기 연결을 할때에 대한 시간 초과가 난 상황을 말하고,- Read timeout은 데이터를 읽는 동안 대기하는 시간 초과입니다. 서버에서 데이터를 받아오는데 시간 초과가 난 경우입니다. \n \n\n\n\n📌 공인 IP와 사설 IP 차이에 대해 설명해주세요.\n- 공인 IP는 ISP(인터넷 서비스 공급자)가 제공하는 IP 주소이며, 외부에 공개되어 있는 IP주소 입니다.\n- 사설 IP는 일반 가정이나 회사 내 등에 할당된 네트워크 IP 주소이며, IPv4의 주소부족으로 인해 서브넷팅된 IP이기 때문에 라우터(공유기)에 의해 로컬 네트워크상의 PC나 장치에 할당됩니다.\n \n- 사설 IP 주소만으로는 인터넷에 연결할 수 없기 때문에, 라우터가 NAT(Network Address Translation)을 이용해서 사설 IP를 공인IP로 바꿔서 내보내줍니다. \n \n\n📌 RESTFul이란 무엇인가요?\n\n \n \n\n📌 TCP / IP 4계층에 대해 설명해주세요\n\n\n\n\n\n\n\n계층\n역할\n데이터 단위\n전송 주소\n예시\n장비\n\n\n응용 계층(Application)\n응용프로그램 간의 데이타 송수신\nData/Message\n-\n파일 전송, 이메일, FTP, HTTP, SSH, Telnet, DNS, SMTP 등\n-\n\n\n전송 계층(Transport)\n호스트 간의 자료 송수신\nSegment\nPort\nTCP, UDP, RTP, RTCP 등\n게이트웨이\n\n\n인터넷 계층(Internet)\n데이타 전송을 위한 논리적 주소 지정 및 경로 지정\nPacket\nIP\nIP, ARP, ICMP, RARP, OSPF\n라우터\n\n\n네트워크 연결 계층(Network Access)\n실제 데이타인 프레임을 송수신\nFrame\nMAC\nEthernet, PPP, Token Ring 등\n브리지, 스위치\n\n\n\n1) L1 네트워크 연결 계층(Network Access Layer/Network Interface Layer)\n- 데이터 단위: 프레임- 전송 주소: MAC\n- 물리적으로 데이타가 네트워크를 통해 어떻게 전송되는지를 정의\n\n논리주소(IP주소 등)가 아닌 물리주소(예. MAC주소(Media Access Control Address))을 참조해 장비간 전송\n\n\n기본적으로 에러검출/패킷의 프레임화 담당\n\n- 예시: MAC, LAN, 패킷망 등에 사용되는 것, Ethernet, PPP, Token Ring 등\n \n2) L2 인터넷 계층(Internet Layer)\n- 데이터 단위: 패킷- 전송 주소: IP\n- 네트워크상 최종 목적지까지 정확하게 연결되도록 연결성을 제공 및 IP 할당 \n- 라우팅(Routing)기능, 즉 경로 설정 기능을 처리 \n- 예시 :  IP, ARP, ICMP, RARP, OSPF\n \n3) L3 전송 계층(Transport Layer)\n- 데이터 단위: Segment- 전송 주소: Port\n- 통신 노드 간의 연결 제어 및 자료 송수신을 담당\n- 애플리케이션 계층의 세션과 데이터그램 통신서비스 제공\n- 예시: TCP, UDP, RTP, RTCP 등\n \n4) L4 응용 계층(Application Layer)\n- 데이터 단위: Data/Message\n- 사용자와 가장 가까운 계층으로 사용자가 소프트웨어 application과 소통할 수 있게 해준다\n\n응용프로그램(application)들이 데이터를 교환하기 위해 사용되는 프로토콜\n사용자 응용프로그램 인터페이스를 담당\n\n예시:  파일 전송, 이메일, FTP, HTTP, SSH, Telnet, DNS, SMTP 등\n \n\n📌 웹서버 소프트웨어(Apache, Nginx)는 OSI 7계층 중 어디서 작동하나요\n \n\n📌 DNS 서버에 대해 설명해주세요\n- DNS서버란 도메인 이름을 IP주소로 바꿔주는 역할을 하는 서버입니다. 이로 인해 클라이언트는 IP주소를 기억하지 않고 해당 주소의 웹사이트에 접근할 수 있습니다.\n- 도메인(Domain) : 웹사이트의 위치 (ex, 도메인 이름 google.com은 IP주소 142.250.196.142를 의미)\n- 도메인과 URL의 차이점 : 웹주소인 URL에는 도메인 이름과 전송 프로토콜 및 경로 등의 정보가 포함되어 있습니다.\n\nRoot 네임 서버 : DNS 레코드를 요청하는 첫 단계입니다. 비영리 단체인 ICANN(Internet Corporation for Assigned Names and Numbers)이 관리합니다.\nTLD(최상위 도메인) 네임 서버 : TLD 네임서버는 .com, .co.kr 과 같은 점 뒤에오는 도메인 확장자를 사용하는 모든 도메인 정보를 유지합니다.\nAuthoritative 네임 서버 : 실제 도메인의 IP주소가 기록되는 서버입니다. 도메인/호스팅 업체의 '네임서버'를 말합니다.\nRecursive(재귀) 네임 서버 : 인터넷 사용자가 가장 먼저 접근하는 DNS 서버로 특정 도메인에 대한 IP정보를 캐시 형태로 저장해놓습니다. 대표적으로 KT/LG/SK 와 같은 ISP(통신사) DNS 서버가 있습니다\n\n📌 라우터는 무엇이고 무슨 기능을 하나요?\n \n\n📌 라우팅 알고리즘에 대해 설명해주세요\n\n📌DHCP란 무엇이고 어떻게 동작되나요?\n\n📌 TDMA와 FDMA에 대해 설명해주세요.\n\n📌 CSMA 방식에 대해 설명해주세요.\n\n📌MAC에 대해 설명해주세요.\n\n📌스위치의 역할에 대해 설명해주세요.\n\n📌 URL과 URI의 차이점을 알려주세요\n \n \n\n\n프레임워크와 라이브러리의 차이점\n\n운영체제\n프로세스와 스레드의 차이를 설명해보세요.컨텍스트 스위칭에 대해 설명해보세요.동기와 비동기의 차이(블로킹, 넌블로킹) / 장단점에 대해 설명해보세요.멀티스레드 프로그래밍에 대해 설명해보세요.Thread-safe 하다는 의미와 설계하는 법을 설명해보세요.프로세스 동기화에 대해 설명해보세요.교착상태와 기아상태의 해결방법에 대해 설명해보세요.세마포어와 뮤텍스의 차이에 대해 설명해보세요.가상 메모리에 대해 설명해보세요.캐시의 지역성에 대해 설명해보세요.프로세스 관련 용어를 설명해보세요. (알아만 둡시다.)\n \n자료구조/알고리즘\n보통의 자료구조/알고리즘적 지식은 코딩테스트로 검증합니다.하지만 아래의 개념을 적어도 이해는 한다고 생각하니, 혹시 모르는 부분이 있을 경우 학습을 권장합니다.\n시간 복잡도를 계산해주세요.배열과 링크드 리스트의 차이를 설명해주세요.List와 Set의 차이에 대해서 설명해주세요.Hash Function, HashTable에 대해서 설명해주세요.Stack, Queue에 대해서 설명해주세요.Heap, Priority Queue에 대해서 설명해주세요.Tree, Binary Tree, BST, AVL Tree에 대해서 설명해주세요.BST의 최악의 경우의 예와 시간복잡도에 대해서 설명해주세요.피보나치 수열을 코드로 구현하는 방법에 대해서 설명해주세요.DFS, BFS에 대해서 설명해주세요.정렬, 탐색에 대해 설명해주세요.\n암호학/보안(간단한 정도)\n비대칭키 암호화, 대칭키 암호화에 대해 간단히 설명해주세요.단방향 암호화에 대해서 간단히 설명해주세요.JWT에 대해서 간단히 설명해주세요.OAuth에 대해서 간단히 설명해주세요.JWT와 OAuth의 차이는 무엇이 있을까요?SQL Injection에 대해서 간단히 설명해주세요.XSS에 대해서 간단히 설명해주세요.CSRF에 대해서 간단히 설명해주세요.\n컴파일러\n스크립트 언어와 컴파일 언어를 나열하고 차이점을 설명해주세요.\n언어 관련\nJava\nJVM의 구조와 Java의 실행방식을 설명해주세요.GC가 무엇인지, 필요한 이유는 무엇인지, 동작방식에 대해 설명해주세요.컬렉션 프레임워크에 대해서 설명해주세요.제네릭에 대해서 설명해주세요.애노테이션에 대해서 설명해주세요.오버라이딩과 오버로딩이 무엇이며 어떤 차이가 있을까요?인터페이스와 추상클래스의 차이점에 대해 설명해주세요.클래스는 무엇이고 객체는 무엇인가요?정적(static)이란 무엇인가요?자바의 원시타입들은 무엇이 있으며 각각 몇 바이트를 차지하나요?접근 제어자의 종류와 이에 대해 설명해주세요.객체지향에 대해서 설명해주세요.SOLID(객체지향 5대원칙)에 대해서 설명해주세요.동일성(identity)와 동등성(equality)에 대해 설명해주세요. (equals(), ==)원시타입과 참조타입의 차이에 대해 설명해주세요.String, StringBuilder, StringBuffer 각각의 차이에 대해 설명해주세요.Checked Exception과 Unchecked Exception에 대해 설명해주세요. 스프링 트랜잭션 추상화에서 rollback 대상은 무엇일까요?Java8에서 추가된 기능에 대해서 설명해주세요.try-with-resource에 대해서 설명해주세요.강한 결합과 느슨한 결합이 무엇인지 설명해주세요.직렬화와 역직렬화에 대해서 설명해주세요.자바의 동시성 이슈(공유자원 접근)에 대해 설명해주세요.Mutable 객체와 Immutable 객체의 차이점에 대해 설명해주세요.자바에서 null을 안전하게 다루는 방법에 대해 설명해주세요.\nSpring\nSpring DI/IoC는 어떻게 동작하나요?Spring Bean이란 무엇인가요?스프링 Bean의 생성 과정을 설명해주세요.스프링 Bean의 Scope에 대해서 설명해주세요.IoC 컨테이너의 역할은 무엇이 있을까요?DI 종류는 어떤것이 있고, 이들의 차이는 무엇인가요?Autowiring 과정에 대해서 설명해주세요.Spring Web MVC의 Dispatcher Servlet의 동작 원리에 대해서 간단히 설명해주세요.프론트 컨트롤러 패턴이란 무엇인가요?Servlet Filter와 Spring Interceptor의 차이는 무엇인가요?Spring에서 CORS 에러를 해결하기 위한 방법을 설명해주세요.Bean/Component 어노테이션에 대해서 설명해주시고, 둘의 차이점에 대해 설명해주세요.POJO란 무엇인가요? Spring Framework에서 POJO는 무엇이 될 수 있을까요?Spring Web MVC에서 요청 마다 Thread가 생성되어 Controller를 통해 요청을 수행할텐데, 어떻게 1개의 Controller만 생성될 수 있을까요?Filter는 Servlet의 스펙이고, Interceptor는 Spring MVC의 스펙입니다. Spring Application에서 Filter와 Interceptor를 통해 예외를 처리할 경우 어떻게 해야 할까요?Spring Application을 구동할 때 메서드를 실행시키는 방법에 대해 설명해주세요.의존성과 설정값을 생성자 인자로 주입해야 하는 이유에 대해 설명해주세요.\nJPA\nJPA 영속성 컨텍스트의 이점(5가지)을 설명해주세요.JPA Propagation 전파단계를 설명해주세요.JPA를 쓴다면 그 이유에 대해서 설명해주세요.N + 1 문제는 무엇이고 이것이 발생하는 이유와 이를 해결하는 방법을 설명해주세요.\nPython\nList와 Tuple의 차이에 대해 설명해주세요.파이썬 코루틴에 대해 아는대로 설명해주세요.파이썬 데코레이터에 대해 아는대로 설명해주세요.GIL에 대해 설명해주세요.MRO에 대해 설명해주세요.Magic Method에 대해 설명해주세요.__new__와 __init__의 차이에 대해 설명해주세요.__repr__와 __str__의 차이에 대해 설명해주세요.r string과 u string에 대해 설명해주세요.Call by Assignment에 대해 설명해주세요.파이썬에서의 접근제어지시자에 대해 아는대로 설명해주세요.global과 nonlocal 키워드의 차이에 대해 설명해주세요.classmethod와 staticmethod의 차이에 대해 설명해주세요.\n기타\n트러블 슈팅\n대용량 트래픽에서 장애가 발생하면 어떻게 대응할 것인가요?\n디자인 패턴\n싱글톤 패턴에 대해서 설명해주세요.(생각보다 어려움)가교 패턴(브릿지 패턴)에 대해서 설명해주세요.전략 패턴에 대해서 설명해주세요.빌더 패턴에 대해서 설명해주세요.팩토리 메서드 패턴에 대해서 설명해주세요.퍼사드 패턴에 대한 예를 들어주세요.\n테스트\n테스트 코드에 대해서 어떻게 생각하고, 작성하나요?TDD를 알고 있나요? TDD에 대해서 어떻게 생각하나요?테스트 커버리지에 대해서 어떻게 생각하나요?\n인프라/클라우드\nAWS 인프라를 구축해보았다면 설명해주세요.로드 밸런서에 대해서 설명해주세요.리버스 프록시에 대해서 설명해주세요.Fault-tolerant(무정지) 시스템으로 가기 위해 필요한 방법에 대한 생각을 말해주세요.\n컨테이너\n제가 아직 도커, 쿠버네티스에 익숙하지 않아 공부가 좀 더 필요합니다.관련해서 질문을 받아본적은 없으나, 일반적인 질문을 담아보았습니다.\nDocker란 무엇이고 컨테이너 가상화를 왜 사용할까요?컨테이너 환경에서의 디버깅은 어떤식으로 하며 상대적으로 어려운 점은 무엇인가요?\nDevOps\nDevOps는 어쩌면 신입에겐 물어보지 않을 수도 있습니다. 하지만 DevOps가 무엇인지 정도는 알아두는게 좋을 것 같습니다.\nCI/CD가 무엇인가요? 왜 CI/CD가 장점이 될까요?DevOps가 무엇인지 설명해주세요.\n커뮤니케이션\n정답이 없는 질문입니다. 면접관마다 의도하는 답이 다 다를테니 자신만의 방법을 한 번 쯤 생각해보고 답변에 막힘이 없도록 준비합시다.\n어떤 기술이나 방법론이 좋아보일 때, 이를 어떻게 설득할 것인가요?일정이 예상보다 지연될 것 같습니다. 어떻게 해결하실 것인가요?팀원과의 갈등이 있었나요? 있었다면 어떻게 대처했나요?\n개인의 역량\n본인이 수행한 프로젝트 중 상용화 가능한 프로젝트가 있나요?기술을 습득할 때 어떤 식으로 습득하나요?\n최신기술에 관심이 있는지\n최신기술에 관심이 있는지 정도를 확인하고자 함입니다. 너무 정확하게 말하지 않아도 관심이 있다는 인상정도를 줄 수 있다면 좋겠습니다.그 회사의 기술 스택을 찾아보고 관심을 가져봤다 정도의 느낌을 줄 수 있어야합니다.사용까지 해보면 더더욱 좋을 것 같습니다.\nprotobuf에 대해서 알고계신가요? 이것은 왜 사용할까요?gRPC는 무엇이며, RPC는 무엇인가요? 왜 쓸까요?쿠버네티스가 무엇인가요? 왜 쿠버네티스를 쓸까요?\n면접 꿀팁\n회사의 기술스택에 관심을 가져보세요. 학습능력이 좋음을 어떤식으로 보여줄 수 있을까요?\n본인이 수행한 프로젝트를 유의미한 트래픽이 나올정도로 해본 경험을 높게 평가하는 회사가 많습니다.\n두괄식으로 답변하도록 합시다. (사실 힘듭니다. 그렇게 될 수 있게끔 연습 또 연습!)\n프로젝트를 수행할 때, 내가 이 기술을 단순히 좋아보여서 사용한 것이 아니라, 많은 고민을 했음을 보여주도록 하세요. 가장 간단한 질문으로는 '왜 그 기술을 사용했나요?', '그 기술 말고 다른 기술은 왜 사용하지 않았나요?', '대체할만한 기술이 있나요?' 등이 있습니다.\n면접 꿀팁 영상!\n\n\n\n\n\n\n\n\n \nhttps://velog.io/@kkj53051000/%EB%8F%84%EB%A9%94%EC%9D%B8Domain%EA%B3%BC-DNS-%EC%A0%95%EB%A6%AC"
    },
    {
        "question": "📌  TCP와 UDP의 차이점에 대해서 설명해보세요.",
        "answer": "- TCP는 Connection Oriented Protocol(연결 지향형 프로토콜)로, 신뢰성있는 데이터전송을 보장합니다. \n- UDP는 Connectionless Protocol로 빠르지만 데이터의 유실 가능성이 존재하는 걸로 알고있습니다. \n- 그래서 일반적인 경우, TCP를 사용하고 데이터가 유실되더라도 실시간성이 중요한 스트리밍방송, 통화 등에서는 UDP를 사용하는것으로 알고 있습니다.\n \n\n \n \n1) TCP 특징\n\n연결형 서비스로 가상 회선 방식을 제공한다.\n3-way handshaking과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다.\n흐름 제어 및 혼잡 제어.\n높은 신뢰성을 보장한다.\nUDP보다 속도가 느리다.\n전이중(Full-Duplex), 점대점(Point to Point) 방식\n\n2) TCP 서버 특징 \n\n서버소켓은 연결만을 담당한다.\n연결과정에서 반환된 클라이언트 소켓은 데이터의 송수신에 사용된다형 서비스로 가상 회선 방식을 제공한다.\n서버와 클라이언트는 1대1로 연결된다.\n스트림 전송으로 전송 데이터의 크기가 무제한이다.\n패킷에 대한 응답을 해야하기 때문에(시간 지연, CPU 소모) 성능이 낮다.\nStreaming 서비스에 불리하다.(손실된 경우 재전송 요청을 하므로)\n\n \n \n\n \n \n\n \n\n3) UDP 특징\n\n비연결형 서비스로 데이터그램 방식을 제공한다\n정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.\nUDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.\n신뢰성이 낮다\nTCP보다 속도가 빠르다\n\n4) UDP 서버 특징 \n\nUDP에는 연결 자체가 없어서(connect 함수 불필요) 서버 소켓과 클라이언트 소켓의 구분이 없다.\n소켓 대신 IP를 기반으로 데이터를 전송한다.\n서버와 클라이언트는 1대1, 1대N, N대M 등으로 연결될 수 있다.\n데이터그램(메세지) 단위로 전송되며 그 크기는 65535바이트로, 크기가 초과하면 잘라서 보낸다.\n흐름제어(flow control)가 없어서 패킷이 제대로 전송되었는지, 오류가 없는지 확인할 수 없다.\n파일 전송과 같은 신뢰성이 필요한 서비스보다 성능이 중요시 되는 경우에 사용된다.\n\n5) UDP는 항상 신뢰성을 보장하지 않나요?\n- UDP도 신뢰성을 UDP자체에서 보장하지 않는 것 뿐이지, 개발자가 직접 신뢰성을 보장하도록 할 수 있습니다. HTTP/3의 경우,  UDP 기반의 QUIC이라는 프로토콜을 사용합니다. UDP 자체는 신뢰성을 보장하지 않지만, 추가적인 정의를 통해 신뢰성을 보장받을 수 있습니다.\n \n\n\n\n프로토콜 종류\nTCP\nUDP\n\n\n연결 방식\n연결형 서비스\n비연결형 서비스\n\n\n패킷 교환 방식\n가상 회선 방식\n데이터그램 방식\n\n\n전송 순서\n전송 순서 보장\n전송 순서가 바뀔 수 있음\n\n\n수신 여부 확인\n수신 여부를 확인함\n수신 여부를 확인하지 않음\n\n\n통신 방식\n1:1 통신\n1:1 OR 1:N OR N:N 통신\n\n\n신뢰성\n높다.\n낮다.\n\n\n속도\n느리다.\n빠르다.\n\n\n\n \n\n📌  TCP의 신뢰성을 보장하는 방법을 설명해보세요.\n1) 패킷(Packet)이란? \n-  데이터를 여러개의 조각으로 나누어 전송 할 때의 조각 단위\n \n2) TCP는 패킷을 어떻게 추적 및 관리하는가? \n- 각 패킷에 번호를 부여한다.\n3) 흐름 제어란?\n- 송신측의 전송량 > 수신측의 수신량 일 경우 발생할 문제를 예방하기 위한 제어\n-  송신측의 패킷 전송량을 제어\n \n ▶ Stop and Wait (정지 - 대기) \n\n매번 전송한 패킷에 대한 확인 응답을 받아야 그 다음 패킷을 전송할 수 있다.\nGive & Take \n\n ▶  Sliding Window(슬라이딩 윈도우) \n\n수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답 없이 세그먼트를 전송한다. \n윈도우 : 송신, 수신 스테이션 양쪽에서 만들어진 버퍼의 크기  \n송신측에서는 Ack 프레임을 수신하지 않더라도 여러 개의 프레임을 연속적으로 전송할 수 있다\n송신측에서 0,1,2,3,4,5,6을 보낼 수 있는 프레임을 가지고 있고 데이터 0,1을 전송했다고 가정하면 슬라이딩 윈도우 구조는 2,3,4,5,6처럼 변하게 된다. \n이때, 만약 수신측으로부터 ACK라는 프레임을 받게 된다면 송신측은 이전에 보낸 데이터 0,1을 수신측에서 정상적으로 받았음을 알게 되고 송신측의 슬라이딩 윈도우는 ACK 프레임에 따른 프레임의 수만큼 오른쪽으로 경계가 확장된다. \n\n \n4) 오류제어란?\n\n오류 검출과 재전송\n\n▶ ARQ (Automatic Repeat Request)\n- TCP는 기본적으로 재전송 기반의 오류 제어를 사용(오류가 발생 시, 송신 -> 수신으로 데이터 재전송) \n- 하지만 실제로 수 많은 데이터를 주고 받아야 하는 네트워크 상황에서 이러한 재전송 방식은 그 자체로 비효율적이기 때문에 이러한 재전송을 최대한 적게하는 여러 방식으로 TCP는 오류를 제어\n \n ▶  Stop and Wait ARQ (Automatic Repeat Request)\n\n송신측에서 1개의 프레임을 송신하고, 수신측에서 수신된 프레임의 에러 유무 판단에 따라 ACK or NAK(Negative Acknowledgement)를 보내는 방식\n식별을 위해 데이터 프레임과 ACK 프레임은 각각 0,1 번호를 번갈아가며 부여한다. \n수신측이 데이터를 받지 못했을 경우, NAK를 보내고 NAK를 받은 송신측은 데이터를 재전송한다. \n만약, 데이터나 ACK가 분실되었을 경우 일정 간격의 시간을 두고 타임아웃이 되면, 송신측은 데이터를 재전송한다. \n\n▶ Go-Back-n ARQ(슬라이딩 윈도우) \n\n전송된 프레임이 손상되거나 분실된 경우 , ACK 패킷의 손실로 인한 TIME_OUT이 발생된 경우, 확인된 마지막 프레임 이후로 모든 프레임을 재전송\n슬라이딩 윈도우는 연속적인 프레임 전송 기법으로 전송측은 전송된 프레임의 복사본을 가지고 있어야 하며, ACK와 NAK 모두 각각 구별해야 한다. \nACK : 다음 프레임을 전송 \nNAK : 손상된 프레임 자체 번호를 반환\n\n▶  SR(Selective-Reject) ARQ\n\nSR ARQ는 손상된, 손실된 프레임만 재전송한다 \n그렇기 때문에 별도의 데이터 재정렬을 수행하야 하며, 별도의 버퍼를 필요로 한다\n수신측에 버퍼를 두어 받은 데이터의 정렬이 필요\n\n\n5) 혼잡제어란?\n\n송신측의 데이터 전달과 네트워크의 데이터 처리 속도를 해결하기 위한 기법\n 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 제어하는 것이 혼잡 제어의 개념이다. \n\n▶   AIMD (Addtive Increase Multicative Decrease) \n\n합 증가 / 곱 감소 알고리즘\n처음에 패킷 하나를 보내는 것으로 시작하여 전송한 패킷이 문제 없이 도착한다면 Window Size를 1씩 증가시키며 전송하는 방법. 만약, 패킷 전송을 실패하거나 TIME_OUT이 발생하면 Window Size를 절반으로 감소시킨다. \n문제점 : 초기 네트워크의 높은 대역폭을 사용하지 못하고 네트워크가 혼잡해지는 상황을 미리 감지하지 못하여 혼잡해지고 나서야 대역폭을 줄이는 방식이다. \n\n▶ Slow Start \n\nSlow Start는 AIMD와 마찬가지로 패킷을 하나씩 보내는 것부터 시작한다. 이 방식은 패킷이 문제 없이 도착하면 ACK 패킷마다 Window Size를 1씩 늘린다. 즉, 한 주기가 지나면 Window Size는 2배가 된다 \n혼잡 현상이 발생하면 Window Size를 1로 떨어뜨린다 \n\n\n\n미리 정해진 임계값(threshold)에 도달할 때까지 윈도우의 크기를 2배씩 증가시킨다. \n전송되는 데이터의 크기가 임계 값에 도달하면 혼잡 회피 단계로 넘어간다 \n\n\n[혼잡 회피(Congestion Avoidance)] \n\n윈도우의 크기가 임계 값에 도달한 이후에는 데이터의 손실이 발생할 확률이 높다 \n따라서 이를 회피하기 위해 윈도우 크기를 선형적으로 1씩 증가시키는 방법\n\n[빠른 회복(Fast Recovery)]\n\n혼잡한 상태가 되면 Window Size를 1로 줄이지 않고 절반으로 줄이고 선형 증가시키는 방법\n빠른 회복 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작\n\n[빠른 재전송(Fast Retransmit)]\n\n수신측에서 패킷을 받을 때 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보낸다. 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보낸다. 따라서 중간에 패킷 하나가 손실되면 송신측에서는 순번이 중복된 ACK 패킷을 받게 된다. 이것을 감지하면 문제가 되는 순번의 패킷을 재전송할 수 있다. \n빠른 재전송은 중복된 순번의 패킷을 3개(3 ACK) 받으면 재전송한다. 그리고 이러한 현상이 일어나는 것은 약간의 혼잡이 발생한 것으로 간주하여 Window Size를 절반으로 줄인다. \n\n출처: https://rok93.tistory.com/entry/네트워크-TCP-흐름제어혼잡제어 [티끌모아 로키산맥 🏔]"
    },
    {
        "question": "💡 Array(List)의 가장 큰 특징과 그로 인해 발생하는 장점과 단점에 대해 설명해주세요.",
        "answer": "Array의 가장 큰 특징은 순차적으로 데이터를 저장한다는 점입니다.데이터에 순서가 있기 때문에 0부터 시작하는 index가 존재하며, index를 사용해 특정 요소를 찾고 조작이 가능하다는 것이 Array의 장점입니다.순차적으로 존재하는 데이터의 중간에 요소가 삽입되거나 삭제되는 경우 그 뒤의 모든 요소들을 한 칸씩 뒤로 밀거나 당겨줘야 하는 단점도 있습니다.이러한 이유로 Array는 정보가 자주 삭제되거나 추가되는 데이터를 담기에는 적절치 않습니다."
    },
    {
        "question": "💡 Array를 적용시키면 좋을 데이터의 예를 구체적으로 들어주세요. 구체적 예시와 함께 Array를 적용하면 좋은 이유, 그리고 Array를 사용하지 않으면 어떻게 되는지 함께 설명해주세요.",
        "answer": "더보기\n\nArray를 적용시키면 좋은 예로 주식 차트가 있습니다.\n주식 차트에 대한 데이터는 요소가 중간에 새롭게 추가되거나 삭제되는 정보가 아니며, 날짜별로 주식 가격이 차례대로 저장되어야 하는 데이터입니다.\n즉, 순서가 굉장히 중요한 데이터이므로 Array 같이 순서를 보장해주는 자료구조를 사용하는 것이 좋습니다.\nArray를 사용하지 않고 순서가 없는 자료 구조를 사용하는 경우에는 날짜별 주식 가격을 확인하기 어려우며 매번 전체 자료를 읽어 들이고 비교해야 하는 번거로움이 발생합니다."
    },
    {
        "question": "💡 Stack과 Queue, Tree와 Heap의 구조에 대해 설명해주세요.",
        "answer": "Stack과 Queue는 선형 자료구조의 일종이며, Array와 LinkedList로 구현할 수 있습니다.Stack은 후입선출(LIFO)방식 즉, 나중에 들어간 원소가 먼저 나오는 구조이고 Queue는 선입선출(FIFO)방식 즉, 먼저 들어간 원소가 먼저 나오는 구조를 갖습니다.Tree는 스택과 큐와 같은 선형 구조가 아닌 비선형 자료구조이며, 계층적 관계를 표현하기에 적합합니다.Heap은 최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조로,각 노드의 키값이 자식의 키값보다 작지 않거나(최대힙) 그 자식의 키값보다 크지 않은(최소힙) 완전이진트리 입니다."
    },
    {
        "question": "💡 Stack과 Queue의 실사용 예를 들어 간단히 설명해주세요.",
        "answer": "Stack - 자바의 Stack 메모리 영역지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메소드 호출시 메모리에 할당되고 종료되면 메모리가 해제되며,LIFO(Last In First Out)구조를 가집니다.Queue - OS의 스케쥴러자원의 할당과 회수를 하는 스케쥴러 역할을 큐가 할 수 있습니다.메모리에 적재된 다수의 프로세스 중 어떤 프로세스에게 자원을 할당할 것인가 그 순서를 결정하는 것이 자원의 효율적인 사용에 있고,가장 단순한 형태의 스케쥴링 정책이 선입선처리(First Com First Served) 즉, 큐라고 볼 수 있습니다."
    },
    {
        "question": "💡 Stack 클래스를 손코딩으로 구현해주세요.",
        "answer": "public class Stack {\n    private static int MAX_STACK_SIZE = 10;\n    private int top;\n    private int[] data = new int[MAX_STACK_SIZE];\n\n    public Stack() {\n        top = -1;\n    }\n\n    public void push(int data_) throws Exception {\n        if (isFull()) {\n            throw new Exception(\"스택이 가득 찼습니다.\");\n        }\n        data[++top] = data_;\n    }\n\n    public int pop() throws Exception {\n        if (isEmpty()) {\n            throw new Exception(\"스택이 비었습니다.\");\n        }\n        return data[top--];\n    }\n\n    public int peek() throws Exception {\n        if (isEmpty()) {\n            throw new Exception(\"스택이 비었습니다.\");\n        }\n        return data[top];\n    }\n\n    public boolean isEmpty() {\n        return top == -1;\n    }\n\n    public boolean isFull() {\n        return top == MAX_STACK_SIZE - 1;\n    }\n\n    public int size() {\n        return top + 1;\n    }\n}"
    },
    {
        "question": "💡 Priority Queue(우선순위 큐)에 대해 설명해주세요.",
        "answer": "우선순위 큐는 들어간 순서에 상관없이 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조입니다.우선순위 큐 구현 방식에는 배열, 연결 리스트, 힙이 있고, 그중 힙 방식이 worst case라도 시간 복잡도 O(logN)을 보장하기 때문에 일반적으로 완전 이진트리 형태의 힙을 이용해 구현합니다."
    },
    {
        "question": "💡 Array와 ArrayList의 차이점에 대해 설명해주세요.",
        "answer": "Array는 크기가 고정적이고, ArrayList는 크기가 가변적입니다.Array는 초기화 시 메모리에 할당되어 ArrayList보다 속도가 빠르고,ArrayList는 데이터 추가 및 삭제 시 메모리를 재할당하기 때문에 속도가 Array보다 느립니다."
    },
    {
        "question": "💡 Array와 LinkedList의 장/단점에 대해 설명해주세요.",
        "answer": "Array는 인덱스(index)로 해당 원소(element)에 접근할 수 있어 찾고자 하는 원소의 인덱스 값을 알고 있으면 O(1)에 해당 원소로 접근할 수 있습니다. 즉, RandomAccess가 가능해 속도가 빠르다는 장점이 있습니다.하지만 삽입 또는 삭제의 과정에서 각 원소들을 shift 해줘야 하는 비용이 생겨 이 경우 시간 복잡도는 O(n)이 된다는 단점이 있습니다.이 문제점을 해결하기 위한 자료구조가 linkedlist입니다. 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있기 때문에 이 부분만 다른 값으로 바꿔주면 삽입과 삭제를 O(1)로 해결할 수 있습니다.하지만LinkedList는 원하는 위치에 한 번에 접근할 수 없다는 단점이 있습니다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 Search 과정에 있어서 첫번째 원소부터 다 확인해봐야 합니다. 간단히 정리하면,Array는 검색이 빠르지만, 삽입, 삭제가 느리다.LinkedList는 삽입, 삭제가 빠르지만, 검색이 느리다."
    },
    {
        "question": "💡 해시 테이블(Hash Table)과 시간 복잡도에 대해 설명해주세요.",
        "answer": "해시 테이블은 (Key, Value)로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조입니다. 빠른 검색 속도를 제공하는 이유는 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문입니다. 각 Key값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 O(1)의 시간 복잡도로 데이터를 조회합니다. 하지만 index값이 충돌이 발생한 경우 Chanining에 연결된 리스트들까지 검색해야 하므로 O(N)까지 증가할 수 있습니다."
    },
    {
        "question": "💡 Hash Map과 Hash Table의 차이점에 대해 설명해주세요.",
        "answer": "동기화 지원 여부와 null 값 허용 여부의 차이가 있습니다."
    },
    {
        "question": "💡 BST(Binary Search Tree)와 Binary Tree에 대해 설명해주세요.",
        "answer": "이진트리(Binary Tree)는 자식 노드가 최대 두 개인 노드들로 구성된 트리이고,이진 탐색 트리(BST)는 이진 탐색과 연결 리스트를 결합한 자료구조입니다.이진 탐색의 효율적인 탐색 능력을 유지하면서, 빈번한 자료 입력과 삭제가 가능하다는 장점이 있습니다. 이진 탐색 트리는 왼쪽 트리의 모든 값은 반드시 부모 노드보다 작아야 하고, 오른쪽 트리의 값은 부모 노드보다 커야 하는 특징이 있습니다.이진 탐색 트리의 탐색 연산은 트리의 높이에 영향을 받아 높이가 h일 때 시간 복잡도는 O(h)이며,트리의 균형이 한쪽으로 치우쳐진 경우 worst case가 되고 O(n)의 시간 복잡도를 가집니다. 이런 worst case를 막기 위해 나온 기법이 RBT(Red-Black Tree)입니다."
    },
    {
        "question": "💡 RBT(Red-Black Tree)에 대해 설명해주세요.",
        "answer": "RBT(Red-Black Tree)는 BST를 기반으로 하는 트리 형식 자료구조이며,RBT는 BST의 삽입, 삭제 연산 과정에서 발생할 수 있는 문제점을 해결하기 위해 만들어졌습니다.BST를 기반으로 하기 때문에 당연히 BST의 특징을 모두 갖습니다.노드의 child가 없을 경우 child를 가리키는 포인터는 NIL 값을 저장합니다. 이러한 NIL들을 leaf node로 간주합니다.모든 노드를 빨간색 또는 검은색으로 색칠하며, 연결된 노드들은 색이 중복되지 않습니다."
    },
    {
        "question": "💡 Java의 특징을 설명해주세요.",
        "answer": "Java는 객체지향 프로그래밍 언어입니다. \n기본 자료형을 제외한 모든 요소들이 객체로 표현되고, 객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어입니다.\n장점\n\nJVM(자바가상머신) 위에서 동작하기 때문에 운영체제에 독립적이다.\nGabageCollector를 통한 자동적인 메모리 관리가 가능하다.\n\n\n단점\n\nJVM 위에서 동작하기 때문에 실행 속도가 상대적으로 느리다.\n다중 상속이나 타입에 엄격하며, 제약이 많다."
    },
    {
        "question": "💡 JVM의 역할에 대해 설명해주세요.",
        "answer": "JVM은 스택 기반으로 동작하며, Java Byte Code를 OS에 맞게 해석 해주는 역할을 하고 가비지컬렉션을 통해 자동적인 메모리 관리를 해줍니다."
    },
    {
        "question": "💡 JVM의 클래스는 언제 로딩 되는지 설명해주세요.",
        "answer": "JVM은 Lazy Loading 메커니즘을 사용한다.\n클래스를 미리 메모리에 올리지 않고 그때마다 필요한 클래스를 메모리에 올려 효율적으로 관리한다.\nstatic 변수와 메서드\n\n인스턴스화 하지 않아도 사용 가능하며 클래스가 로드된다.\n\n\ninner 클래스와 static inner 클래스\n\ninner 클래스: outer 클래스와 inner 클래스 둘 다 로드된다.\nstatic inner 클래스: outer 클래스를 로드하지 않고 인스턴스화가 가능하다.\n\n\nstatic final 키워드의 상수\n\n클래스 로드되지 않고 사용 가능하다.\n왜냐하면 컴파일 시점에 값이 확정되기 때문에 JVM의 Method Area의 Constant Pool에 따로 저장되어 관리되기 때문이다.\n\n\n그럼 final 키워드의 상수는?\n\n런타임 시점에 값이 결정되므로 클래스가 로드되어야 사용 가능하며 각 객체별로 값을 유지한다. \n인스턴스 변수일 경우 Heap, 지역 변수일 경우 Stack에 저장되며 객체 생성시 초기화된다."
    },
    {
        "question": "💡 JVM의 클래스는 언제 초기화 되는지 설명해주세요.",
        "answer": "클래스 초기화 시점\n\n클래스의 인스턴스 생성\n클래스의 정적 메소드 호출\n클래스의 정적 변수 값 할당 및 사용\n\n클래스  인스턴스 초기화 순서\n1. 정적 변수 초기화\n2. 정적 블록 실행\n3. 인스턴스 생성\n4. 생성자 실행"
    },
    {
        "question": "💡 Java의 컴파일 과정에 대해 설명해주세요.",
        "answer": "개발자가 .java 파일을 생성한다.\nbuild를 한다.\njava compiler의 javac의 명령어를 통해 바이트코드(.class)를 생성한다.\nClass Loader를 통해 JVM 메모리 내로 로드한다.\n실행엔진을 통해 컴퓨터가 읽을 수 있는 기계어로 해석된다.(각 운영체제에 맞는 기계어)"
    },
    {
        "question": "💡 Java에서 제공하는 원시 타입들에 무엇이 있고, 각각 몇 바이트를 차지하나요?",
        "answer": "정수형 byte, short, int, long 실수형 float, double 문자형 char 논리형 boolean이 있고,\n정수형 1, 2, 4, 8, 실수형 4, 8, 문자형 2, 논리형 1 바이트를 차지합니다."
    },
    {
        "question": "💡 오버라이딩(Overriding)과 오버로딩(Overloading)에 대해 설명해주세요.",
        "answer": "오버라이딩(Overriding)은 상위 클래스에 있는 메소드를 하위 클래스에서 재정의 하는 것을 말하고,\n오버로딩(Overloading)은 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메소드를 여러 개 정의하는 것을 말합니다."
    },
    {
        "question": "💡 객체지향 프로그래밍(OOP)에 대해 설명해주세요.",
        "answer": "우리가 실생활에서 쓰는 모든 것을 객체라 하며, 객체 지향 프로그래밍은 프로그램 구현에 필요한 객체를 파악하고 상태와 행위를 가진 객체를 만들고 각각의 객체들의 역할이 무엇인지를 정의하여 객체들 간의 상호작용을 통해 프로그램을 만드는 것을 말합니다.즉, 기능이 아닌 객체가 중심이며 \"누가 어떤 일을 할 것인가?\"가 핵심특징으로는 캡슐화, 상속, 다형성, 추상화 등이 있고, 모듈 재사용으로 확장 및 유지보수가 용이합니다."
    },
    {
        "question": "💡 try-with-resources에 대해 설명해주세요.",
        "answer": "try-with-resources는 try-catch-finally의 문제점을 보완하기 위해 나온 개념입니다.\ntry( ... ) 안에 자원 객체를 전달하면, try블록이 끝나고 자동으로 자원 해제 해주는 기능을 말합니다.\n따로 finally 구문이나 모든 catch 구문에 종료 처리를 하지 않아도 되는 장점이 있습니다.\ntry-with-resources 알아보기"
    },
    {
        "question": "💡 불변 객체가 무엇인지 설명하고 대표적인 Java의 예시를 설명해주세요.",
        "answer": "불변 객체는 객체 생성 이후 내부의 상태가 변하지 않는 객체를 말합니다.\nJava에서는 필드가 원시 타입인 경우 final 키워드를 사용해 불변 객체를 만들 수 있고,\n참조 타입일 경우엔 추가적인 작업이 필요합니다."
    },
    {
        "question": "💡 참조 타입일 경우 추가적인 작업은 어떤게 있는지 설명해주세요.",
        "answer": "참조 타입은 대표적으로 1.객체를 참조할 수도 있고, 2.배열이나 3.List 등을 참조할 수 있습니다.\n \n1. 참조 변수가 일반 객체인 경우 객체를 사용하는 필드의 참조 변수도 불변 객체로 변경해야 합니다.\n \n2. 배열일 경우 배열을 받아 copy해서 저장하고, getter를 clone으로 반환하도록 하면 됩니다.\n(배열을 그대로 참조하거나, 반환할 경우 외부에서 내부 값을 변경할 수 있음. 때문에 clone을 반환해 외부에서 값 변경하지 못하게 함)\n \n3. 리스트인 경우에도 배열과 마찬가지로 생성시 새로운 List를 만들어 값을 복사하도록 해야 합니다.\n배열과 리스트는 내부를 복사하여 전달하는데, 이를 방어적 복사(defensive-copy)라고 합니다."
    },
    {
        "question": "💡 불변 객체나 final을 굳이 사용해야 하는 이유가 있을까요?",
        "answer": "불변 객체나 final 키워드를 사용해 얻는 이점은 다음과 같습니다.\n \n1. Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.\n(공유 자원이 불변이기 때문에 항상 동일한 값을 반환하기 때문)\n \n2. 실패 원자적인 메소드를 만들 수 있다.\n(어떠한 예외가 발생되더라도 메소드 호출 전의 상태를 유지할 수 있어 예외 발생 전과 똑같은 상태로 다음 로직 처리 가능)\n \n3. 부수효과를 피해 오류를 최소화 할 수 있다.\n※ 부수효과 : 변수의 값이 바뀌거나 객체의 필드 값을 설정하거나 예외나 오류가 발생하여 실행이 중단되는 현상\n \n4. 메소드 호출 시 파라미터 값이 변하지 않는다는 것을 보장할 수 있다.\n \n5. 가비지 컬렉션 성능을 높일 수 있다.\n(가비지 컬렉터가 스캔하는 객체의 수가 줄기 때문에 Gc 수행 시 지연시간도 줄어든다.)"
    },
    {
        "question": "💡 추상 클래스와 인터페이스를 설명해주시고, 차이에 대해 설명해주세요.",
        "answer": "추상 클래스는 클래스 내 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우를 말하고,\n인터페이스는 모든 메소드가 추상 메소드로만 이루어져 있는 것을 말합니다.\n공통점\n\nnew 연산자로 인스턴스 생성 불가능\n사용하기 위해서는 하위 클래스에서 확장/구현 해야 한다.\n\n\n차이점\n\n인터페이스는 그 인터페이스를 구현하는 모든 클래스에 대해 특정한 메소드가 반드시 존재하도록 강제함에 있고, \n추상클래스는 상속받는 클래스들의 공통적인 로직을 추상화 시키고, 기능 확장을 위해 사용한다.\n추상클래스는 다중상속이 불가능하지만, 인터페이스는 다중상속이 가능하다."
    },
    {
        "question": "💡 싱글톤 패턴에 대해 설명해주세요.",
        "answer": "싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴입니다.\n인스턴스가 1개만 존재해야 한다는 것을 보장하고 싶은 경우와\n동일한 인스턴스를 자주 생성해야 하는 경우에 주로 사용합니다. (메모리 낭비 방지)\n싱글톤 패턴(Singleton Pattern)알아보기"
    },
    {
        "question": "💡 싱글톤 패턴의 대표적인 예시를 간단하게 설명해주세요.",
        "answer": "싱글톤 패턴의 대표적인 예시는 Spring Bean 입니다.\n스프링의 빈 등록 방식은 기본적으로 싱글톤 스코프이고, 스프링 컨테이너는 모든 빈들을 싱글톤으로 관리합니다.\n \n스프링은 요청할 때마다 새로운 객체를 생성해서 반환하는 기능도 제공한다. (프로토타입 빈, @Scope(\"prototype\"))"
    },
    {
        "question": "💡 가비지 컬렉션(Garbage Collection)에 대해 설명해주세요.",
        "answer": "가비지 컬렉션은 JVM의 메모리 관리 기법 중 하나로 시스템에서 동적으로 할당됐던 메모리 영역 중에서 필요없어진 메모리 영역을 회수하여 메모리를 관리해주는 기법입니다."
    },
    {
        "question": "💡 가비지 컬렉션 과정에 대해 설명해주세요.",
        "answer": "GC의 작업을 수행하기 위해 JVM이 어플리케이션의 실행을 잠시 멈추고, GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업을 중단 후 (Stop The World 과정) 사용하지 않는 메모리를 제거(Mark and Sweep 과정)하고 작업이 재개됩니다.\n++ GC의 작업은 Young 영역에 대한 Minor GC와 Old 영역에 대한 Major GC로 구분됩니다."
    },
    {
        "question": "💡 객체지향의 설계원칙에 대해 설명해주세요.",
        "answer": "SRP - 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 한다.\nOCP - 개방-폐쇄 원칙 : 확장에는 열려있고, 수정에는 닫혀있어야 한다.\nLSP - 리스코프 치환 원칙 : 하위 타입은 항상 상위 타입을 대체 할 수 있어야 한다.\nISP - 인터페이스 분리 원칙 : 인터페이스 내에 메소드는 최소한 일수록 좋다. (하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다.) SRP와 같은 문제에 대한 두 가지 다른 해결책이다.\nDIP - 의존관계 역전 원칙 : 구체적인 클래스보다 상위 클래스, 인터페이스, 추상클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺어라. DIP 원칙을 따르는 가장 인기 있는 방법은 의존성 주입(DI)이다."
    },
    {
        "question": "💡 자바의 메모리 영역에 대해 설명해주세요.",
        "answer": "자바의 메모리 공간은 크게 Method 영역, Stack 영역, Heap 영역으로 구분되고, 데이터 타입에 따라 할당됩니다.\n메소드(Method) 영역 : 전역변수와 static변수를 저장하며, Method영역은 프로그램의 시작부터 종료까지 메모리에 남아있다.\n스택(Stack) 영역 : 지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메소드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제된다. LIFO(Last In First Out) 구조를 갖고 변수에 새로운 데이터가 할당되면 이전 데이터는 지워진다.\n힙(Heap) 영역 : new 키워드로 생성되는 객체(인스턴스), 배열 등이 Heap 영역에 저장되며, 가비지 컬렉션에 의해 메모리가 관리되어 진다."
    },
    {
        "question": "💡 각 메모리 영역이 할당되는 시점은 언제인가요?",
        "answer": "Method 영역 : JVM이 동작해서 클래스가 로딩될 때 생성\nStack 영역 : 메소드가 호출될 때 할당\nHeap 영역 : 런타임시 할당"
    },
    {
        "question": "💡 클래스와 객체에 대해 설명해주세요.",
        "answer": "클래스는 객체를 만들어내기 위한 설계도 혹은 틀 이라고 할 수 있고, 객체를 생성하는데 사용합니다.객체는 설계도(클래스)를 기반으로 생성되며, 자신의 고유 이름과 상태, 행동을 갖습니다. 여기서 상태는 필드(fields), 행동은 메소드(Method)라고 표현합니다. 객체에 메모리가 할당되어 실제로 활용되는 실체는 '인스턴스'라고 부릅니다."
    },
    {
        "question": "💡 생성자(Constructor)에 대해 설명해주세요.",
        "answer": "생성자는 클래스와 같은 이름의 메소드로, 객체가 생성될 때 호출되는 메소드입니다.명시적으로 생성자를 만들지 않아도 default로 만들어지며, 생성자는 파라미터를 다르게하여 오버로딩할 수 있습니다."
    },
    {
        "question": "💡 Wrapper Class란 무엇이며, Boxing과 UnBoxing은 무엇인지 설명해주세요.",
        "answer": "기본 자료형(Primitive data type)에 대한 객체 표현을 Wrapper class라고 합니다.\n기본 자료형 → Wrapper class로 변환하는 것을 Boxing이라 하며,\nWrapper class → 기본 자료형으로 변환하는 것을 UnBoxing이라 합니다.\nWrapper클래스란?"
    },
    {
        "question": "💡 Synchronized에 대해 아는 대로 말해주세요.",
        "answer": "여러 개의 쓰레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 쓰레드를 제외하고 나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념입니다.\n데이터의 thread-safe를 하기 위해 자바에서 Synchronized 키워드를 제공해 멀티 쓰레드 환경에서 쓰레드간 동기화를 시켜 데이터의 thread-safe를 보장합니다.\nSynchronized는 변수와 메소드에 사용해서 동기화 할 수 있으며, Synchronized 키워드를 남발하게 되면 오히려 프로그램의 성능저하를 일으킬 수 있습니다."
    },
    {
        "question": "💡 new String()과 리터럴(\"\")의 차이에 대해 설명해주세요.",
        "answer": "new String()은 new 키워드로 새로운 객체를 생성하기 때문에 Heap 메모리 영역에 저장되고,\n\"\"는 Heap 안에 있는 String Constant Pool 영역에 저장됩니다."
    },
    {
        "question": "💡 String, StringBuffer, StringBuilder의 차이를 설명해주세요.",
        "answer": "String은 불변의 속성을 가지며, StringBuffer와 StringBuilder는 가변의 속성을 가집니다.\nStringBuffer는 동기화를 지원하여 멀티 쓰레드 환경에서 주로 사용하며,\nStringBuilder는 동기화를 지원하지 않아 싱글 쓰레드 환경에서 주로 사용합니다.\nString, StringBuffer, StringBuilder의 차이와 장단점"
    },
    {
        "question": "💡 String 객체가 불변인 이유에 대해 아는대로 설명해주세요.",
        "answer": "1. 캐싱 기능에 의한 메모리 절약과 속도 향상\n- Java에서 String 객체들은 Heap의 String Pool 이라는 공간에 저장되는데, 참조하려는 문자열이 String Pool에 존재하는 경우 새로 생성하지 않고 Pool에 있는 객체를 사용하기 때문에 특정 문자열 값을 재사용하는 빈도가 높을 수록 상당한 성능 향상을 기대할 수 있다.\n2. thread-safe\n- String 객체는 불변이기 때문에 여러 쓰레드에서 동시에 특정 String 객체를 참조하더라도 안전하다.\n3. 보안기능\n- 중요한 데이터를 문자열로 다루는 경우 강제로 해당 참조에 대한 문자열 값을 바꾸는 것이 불가능하기 때문에 보안에 유리하다."
    },
    {
        "question": "💡 접근 제한자(Access Modifier)에 대해 설명해주세요.",
        "answer": "변수 또는 메소드의 접근 범위를 설정해주기 위해서 사용하는 Java의 예약어를 의미하며, 총 4 가지 종류가 있습니다.\npublic - 접근 제한이 없다. (같은 프로젝트 내 어디서든 사용 가능)\nprotected - 해당 패키지 내, 다른 패키지에서 상속받아 자손 클래스에서 접근 가능하다.\n(default) - 해당 패키지 내에서만 접근 가능\nprivate - 해당 클래스에서만 접근 가능"
    },
    {
        "question": "💡 클래스 멤버 변수 초기화 순서에 대해 설명해주세요.",
        "answer": "static 변수 선언부 : 클래스가 로드 될 때 변수가 제일 먼저 초기화 된다.\n필드 변수 선언부 : 객체가 생성될 때 생성자 block 보다 앞서 초기화 된다.\n생성자 block : 객체가 생성될 때 JVM이 내부적으로 locking( thread-safe 영역 )"
    },
    {
        "question": "💡 static에 대해 설명해주세요.",
        "answer": "static 키워드를 사용한 변수나 메소드는 클래스가 메모리에 올라갈 때 자동으로 생성되며 클래스 로딩이 끝나면 바로 사용할 수 있습니다. 즉, 인스턴스(객체) 생성 없이 바로 사용 가능합니다.\n모든 객체가 메모리를 공유한다는 특징이 있고, GC 관리 영역 밖에 있기 때문에 프로그램이 종료될 때까지 메모리에 값이 유지된 채로 존재하게 됩니다.\nstatic 변수와 static 메소드"
    },
    {
        "question": "💡 static을 사용하는 이유에 대해 설명해주세요.",
        "answer": "static은 자주 변하지 않는 값이나 공통으로 사용되는 값 같은 공용자원에 대한 접근에 있어서 매번 메모리에 로딩하거나 값을 읽어들이는 것보다 일종의 '전역변수'와 같은 개념을 통해 접근하는 것이 비용도 줄이고 효율을 높일 수 있습니다.\n인스턴스 생성 없이 바로 사용 가능하기 때문에 프로그램 내에서 공통으로 사용되는 데이터들을 관리할 때 이용합니다."
    },
    {
        "question": "💡 Inner Class(내부 클래스)의 장점에 대해 설명해주세요.",
        "answer": "1. 내부 클래스에서 외부 클래스의 멤버에 손쉽게 접근할 수 있다.2. 서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써, 캡슐화를 증가시키고, 코드의 복잡성을 낮출 수 있다.3. 외부에서는 내부 클래스에 접근할 수 없으므로, 코드의 보안성을 높일 수 있다."
    },
    {
        "question": "💡 내부 클래스를 static으로 해야 하는 이유에 대해 알고 있나요?",
        "answer": "외부 참조로 인한 메모리 누수 현상을 방지하기 위함\n내부 클래스가 바깥 클래스를 외부 참조함으로써, 외부 클래스는 필요 없어지고 내부 클래스만 남아있을 경우 외부 클래스를 GC 대상으로 삼아 메모리에서 제거해야 하지만, 외부 참조로 인하여 메모리에서 제거되지 않고 잔존하게 된다."
    },
    {
        "question": "💡 리플렉션(Reflection)이란 무엇인지 설명해주세요.",
        "answer": "리플렉션이란 구체적인 클래스 타입을 알지 못해도 그 클래스의 메소드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API 입니다."
    },
    {
        "question": "💡 리플렉션은 어떤 경우에 사용되는지 설명해주세요.",
        "answer": "코드를 작성할 시점에는 어떤 타입의 클래스를 사용할지 모르지만, 런타임 시점에 지금 실행되고 있는 클래스를 가져와서 실행해야 하는 경우 사용됩니다.\n프레임워크나 IDE에서 이런 동적인 바인딩을 이용한 기능을 제공합니다. intelliJ의 자동완성 기능, 스프링의 어노테이션이 리플렉션을 이용한 기능이라 할 수 있습니다."
    },
    {
        "question": "💡 Error와 Exception의 차이를 설명해주세요.",
        "answer": "Error는 실행 중 일어날 수 있는 치명적 오류를 말합니다. 컴파일 시점에 체크할 수 없고, 오류가 발생하면 프로그램은 비정상 종료되며 예측 불가능한 UncheckedException에 속합니다.\n반면, Exception은 Error보다 비교적 경미한 오류이며, try-catch를 이용해 프로그램의 비정상 종료를 막을 수 있습니다.\n예외 처리(Exception) 알아보기"
    },
    {
        "question": "💡 CheckedException과 UnCheckedException의 차이를 설명해주세요.",
        "answer": "CheckedException은 실행하기 전에 예측 가능한 예외를 말하고, 반드시 예외 처리를 해야 합니다.\n\n대표적인 Exception - IOException, ClassNotFoundException 등\n\n\nUncheckedException은 실행하고 난 후에 알 수 있는 예외를 말하고, 따로 예외처리를 하지 않아도 됩니다.\n\n대표적인 Exception - NullPointerException, ArrayIndexOutOfBoundException 등\n\n\nRuntimeException은 UncheckedException을 상속한 클래스이고, RuntimeException이 아닌 것은 CheckedException을 상속한 클래스 입니다.\nCheckedException, UnCheckedException"
    },
    {
        "question": "💡 Optional API에 대해 설명해주세요.",
        "answer": "개발할때 가장 많이 발생하는 예외 중 하나가 NPE(NullPointerException)입니다.NPE를 피하려면 null 여부 검사를 필연적으로 하게 되는데 만약 null 검사를 해야하는 변수가 많은 경우 코드가 복잡해지고 번거롭습니다. 하지만 Java8 부터 Optional<T>을 제공하여 null로 인한 예외가 발생하지 않도록 도와주고, Optional 클래스의 메소드를 통해 null을 컨트롤 할 수 있습니다."
    },
    {
        "question": "💡 컬렉션 프레임워크에 대해 설명해주세요.",
        "answer": "다수의 데이터를 쉽고 효과적으로 관리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 의미합니다.\n자바 컬렉션에는 List, Set, Map 인터페이스를 기준으로 여러 구현체가 존재하고, 이에 더해 Stack, Queue 인터페이스도 존재합니다.\n자바 컬렉션 프레임워크 알아보기"
    },
    {
        "question": "💡 List, Set, Map, Stack, Queue의 특징에 대해 설명해주세요.",
        "answer": "더보기\n\n\nList는 순서가 있는 데이터의 집합이며, 데이터의 중복을 허용합니다. 대표적인 구현체로는 ArrayList가 있고, 이는 Vector를 개선한 것입니다. 이외에도 LinkedList 등의 구현체가 있습니다.\n\nVector, ArrayList, LinkedList, Stack, Queue\n\n\nSet은 순서가 없는 데이터의 집합이며, 데이터의 중복을 허용하지 않습니다. 대표적인 구현체로는 HashSet이 있고, 순서를 보장하기 위해서는 LinkedHashSet을 사용합니다. (Map의 key-value 구조에서 key 대신 value가 들어가 value를 key로 하는 자료구조)\n\nHashSet, LinkedHashSet, TreeSet\n\n\nMap은 키와 값이 한 쌍으로 이뤄져 있고, 키를 기준으로 중복을 허용하지 않으며, 순서가 없습니다. key의 순서를 보장하기 위해서는 LinkedHashMap을 사용합니다.\n\nHashMap, TreeMap, HashTable, Properties\n\n\nStack 객체는 직접 new 키워드로 사용할 수 있으며, Queue 인터페이스는 LinkedList에 new 키워드를 적용해 사용할 수 있습니다."
    },
    {
        "question": "💡 Set과 Map의 타입이 Wrapper Class가 아닌 Object를 받을 때 중복 검사는 어떻게 할건지 설명해주세요.",
        "answer": "hashCode() 메소드를 오버라이딩하여 리턴된 해시코드 값이 같은지를 보고 해시코드 값이 다르다면 다른 객체로 판단하고,해시코드 값이 같으면 equals() 메소드를 오버라이딩하여 다시 비교합니다. 이 두 개가 모두 맞으면 중복 객체입니다."
    },
    {
        "question": "💡 Vector와 List의 차이를 설명해주세요.",
        "answer": "벡터는 데이터 삽입시 원소를 밀어내지만 리스트는 노드를 연결만 하기 때문에, 삽입 삭제 부분에서 리스트가 시간복잡도의 우위를 가집니다.\n벡터는 랜덤부분접근이 가능하지만 리스트는 더블링크드리스트(노드가 양쪽으로 연결)로 되어있기 때문에 랜덤 접근이 되지 않습니다. 검색적인 측면에서는 벡터가 우위에 있습니다.\n벡터는 리스트와 달리 항상 동기화되는 장점이자 단점을 가지고 있습니다. 멀티 쓰레드 환경에서 안전하게 객체를 추가하고 삭제할 수 있지만, 단일쓰레드 환경 일때도 동기화를 하기 때문에 List보다 성능이 떨어집니다."
    },
    {
        "question": "💡 제네릭에 대해 설명해주시고, 왜 쓰는지 알려주세요.",
        "answer": "제네릭은 데이터의 타입을 하나로 지정하지 않고 사용할 때마다 범용적이고 포괄적으로 지정한다는 의미입니다.\n제네릭 타입을 사용함으로써 잘못된 타입이 사용될 수 있는 문제를 컴파일 과정에서 제거할 수 있어 에러를 사전에 방지할 수 있습니다.\n제네릭 알아보기"
    },
    {
        "question": "💡 제네릭의 불공변성에 대해 간단히 설명해주세요.",
        "answer": "제네릭의 불공변성은 타입 안정성을 위한 설계 원칙이며,\n제네릭 타입이 서로 다른 타입을 가지면 상속 관계와 무관하게 서로 다른 타입으로 취급됩니다.\n\nList<Number> numberList = new ArrayList<>();\nList<Integer> integerList = new ArrayList<>();\nnumberList = integerList // number는 integer의 상위타입이지만, 불공변적으로 서로 대입할 수 없다.\n\n불공변성을 유연하게 처리하기 위해 와일드카드를 사용할 수 있다.\n<? extends Type>, <? super Type>"
    },
    {
        "question": "💡 final / finally / finalize 의 차이를 설명해주세요.",
        "answer": "final은 클래스, 메소드, 변수, 인자를 선언할 때 사용할 수 있으며, 한 번만 할당하고 싶을 때 사용합니다.\n\nfinal 변수는 한 번 초기화되면 그 이후에 변경할 수 없습니다.\nfinal 메소드는 다른 클래스가 이 클래스를 상속할 때 메소드 오버라이딩을 금지합니다.\nfinal 클래스는 다른 클래스에서 이 클래스를 상속할 수 없습니다.\n\n\nfinally는 try-catch와 함께 사용되며, try-catch가 종료될 때 finally block이 항상 수행되기 때문에 마무리 해줘야 하는 작업이 존재하는 경우에 해당하는 코드를 작성해주는 코드 블록입니다.\nfinalize는 Object 클래스에 정의되어 있는 메소드이며, GC에 의해 호출되는 메소드로 절대 호출해서는 안되는 메소드입니다. GC가 발생하는 시점이 불분명하기 때문에 해당 메소드가 실행된다는 보장이 없고, finalize() 메소드가 오버라이딩 되어 있으면 GC가 이루어질 때 바로 Garbage Collectiong 되지 않습니다. GC가 지연되면서 OOME(Out of Memory Exception)이 발생할 수 있기 때문에 finalize() 메소드를 오버라이딩하여 구현하는 것을 권장하지 않고 있습니다."
    },
    {
        "question": "💡 직렬화(Serialize)에 대해 설명해주세요.",
        "answer": "시스템 내부에서 사용되는 객체 또는 데이터를 외부의 시스템에서도 사용할 수 있도록 바이트(byte) 형태로 데이터 변환하는 기술이며, 반대로 직렬화된 바이트 형태의 데이터를 다시 객체로 변환하는 과정을 '역직렬화'라고 합니다.\n(간단히) JVM의 메모리에 상주(힙 or 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술"
    },
    {
        "question": "💡 SerialVersionUID를 선언해야 하는 이유에 대해 설명해주세요.",
        "answer": "JVM은 직렬화와 역직렬화를 하는 시점의 클래스에 대한 버전 번호를 부여하는데, 만약 그 시점에 클래스의 정의가 바뀌어 있다면 새로운 버전 번호를 할당하게 됩니다. 그래서 직렬화할 때의 버전 번호와 역직렬화를 할 때의 버전 번호가 다르면 역직렬화가 불가능하게 될 수 있기 때문에 이런 문제를 해결하기 위해 SerialVersionUID를 사용합니다.\n만약 직렬화할 때 사용한 SerialVersionUID의 값과 역직렬화 하기 위해 사용했던 SVUID가 다르다면 InvalidClassException이 발생할 수 있다."
    },
    {
        "question": "💡 인스턴스 초기화 블럭과 정적 초기화 블럭에 대해 설명해주세요",
        "answer": "특징\n인스턴스 초기화 블럭\n정적 초기화 블럭\n\n\n실행 시점\n객체가 생성되기 직전\n클래스가 처음 로드될 때\n\n\n실행 횟수\n객체가 생성될 때마다 실행\n한 번만 실행\n\n\n사용 목적\n객체별 공통 초기화 코드 작성\n정적 변수 초기화 또는 클래스 단위 작업\n\n\n키워드\n{  }\nstatic {  }"
    },
    {
        "question": "💡 HTTP 프로토콜에 대해 설명해주세요.",
        "answer": "HTTP(Hyper Text Transfer Protocol)이란 데이터를 주고 받기 위한 프로토콜이며, 서버/클라이언트 모델을 따릅니다.HTTP는 상태 정보를 저장하지 않는 Stateless의 특징과 클라이언트의 요청에 맞는 응답을 보낸 후 연결을 끊는 Connectionless의 특징을 가지고 있습니다."
    },
    {
        "question": "💡 HTTP와 HTTPS의 차이점은 무엇인가요?",
        "answer": "HTTP는 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 중요한 정보를 주고 받으면 제 3자에 의해 조회될 수 있습니다. 이러한 문제를 해결하기 위해 HTTP에 암호화가 추가된 프로토콜이 HTTPS입니다.HTTPS는 SSL의 껍질을 덮어쓴 HTTP라고 할 수 있습니다."
    },
    {
        "question": "💡 쿠키(Cookie)와 세션(Session)의 차이점에 대해 말해주세요.",
        "answer": "쿠키는 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일입니다. HTTP에서 클라이언트의 상태 정보를 PC에 저장했다가 필요시 정보를 참조하거나 재사용할 수 있습니다.세션은 일정 시간동안 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 유지시키는 기술입니다.즉, 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션이라고 합니다."
    },
    {
        "question": "💡 TCP와 UDP의 차이를 설명해주세요.",
        "answer": "TCP는 연결형 서비스로 3-way handshaking 과정을 통해 연결을 설정하기 때문에 높은 신뢰성을 보장하지만, 속도가 비교적 느리다는 단점이 있습니다.UDP는 비연결형 서비스로 3-way handshaking을 사용하지 않기 때문에 신뢰성이 떨어지는 단점이 있지만, 데이터 수신 여부를 확인하지 않기 때문에 속도가 빠르다는 장점이 있습니다.TCP는 신뢰성이 중요한 파일 교환과 같은 경우에 쓰이고 UDP는 실시간성이 중요한 스트리밍에 자주 사용됩니다."
    },
    {
        "question": "💡 3 way-handshaking 얘기 해주셨는데, TCP 통신은 종료시에도 3 way-handshaking을 사용하나요?",
        "answer": "더보기\n\nTCP는 3 way-handshaking 과정을 통해 연결을 설정하고, 4 way-handshaking 과정을 통해 연결을 해제합니다."
    },
    {
        "question": "💡 3 way-handshake와 4 way-handshake를 설명해주세요.",
        "answer": "3 way-handshake란 TCP 네트워크에서 통신 하는 장치가 서로 연결이 잘 되었는지 확인하는 방법입니다. 송신자와 수신자는 총 3번에 걸쳐 데이터를 주고 받으며 통신이 가능한 상태인지 확인합니다.4 way-handshake란 TCP 네트워크에서 통신 하는 장치의 연결을 해제하는 방법입니다. 송신자와 수신자는 총 4번에 걸쳐 데이터를 주고 받으며 연결을 끊습니다."
    },
    {
        "question": "💡 HTTP Method와 각각이 사용되는 경우에 대해서 설명해주세요.",
        "answer": "HTTP 메소드는 클라이언트가 서버에게 사용자 요청의 목적을 알리는 '수단'입니다."
    },
    {
        "question": "💡 GET과 POST의 차이에 대해 설명해주세요.",
        "answer": "GET은 데이터를 조회하기 위해 사용되는 방식으로 데이터를 헤더에 추가하여 전송하는 방식입니다.URL에 데이터가 노출되므로 보안적으로 중요한 데이터를 포함해서는 안됩니다.POST는 데이터를 추가 또는 수정하기 위해 사용되는 방식으로 데이터를 바디에 추가하여 전송하는 방식입니다.완전히 안전하다는 것은 아니지만 URL에 데이터가 노출되지 않아 GET 보다는 안전합니다."
    },
    {
        "question": "💡 세션 기반 인증과 토큰 기반 인증의 차이에 대해 얘기해주세요.",
        "answer": "세션 기반 인증은 클라이언트로부터 요청을 받으면 클라이언트의 상태 정보를 저장하므로 Stateful한 구조를 가지고,토큰 기반 인증은 상태 정보를 서버에 저장하지 않으므로 Stateless한 구조를 가집니다."
    },
    {
        "question": "💡 그렇다면 Stateful한 세션 기반의 인증 방식을 사용하게 된다면 어떠한 단점이 있을까요?",
        "answer": "더보기\n\n1. 서버에 세션을 저장하기 때문에 사용자가 증가하면 서버에 과부하를 줄 수 있어 확장성이 낮습니다. \n2. 해커가 훔친 쿠키를 이용해 요청을 보내면 서버는 올바른 사용자가 보낸 요청인지 알 수 없습니다. (세션 하이재킹 공격)"
    },
    {
        "question": "💡 그렇다면 세션 기반 인증과 토큰 기반 인증은 각각 어느 경우에 적합한가요?",
        "answer": "더보기\n\n단일 도메인이라면 세션 기반 인증을 사용하고, 아니라면 토큰 기반 인증을 사용하는 것이 적합하다고 생각합니다.\n왜? - 세션을 관리할 때 사용되는 쿠키는 단일 도메인 및 서브 도메인에서만 작동하도록 설계되어 있기 때문에 여러 도메인에서 관리하는 것은 어렵습니다. (CORS 문제)"
    },
    {
        "question": "💡 JWT 토큰에 대해 설명해주세요.",
        "answer": "JWT는 JSON 포맷을 이용하는 Claim 기반의 웹 토큰이며, 토큰 자체를 정보로 사용하는 Self-Contained 방식으로 정보를 안전하게 전달합니다.JWT는 헤더(Header).내용(Payload).서명(Signature)로 구성되며 각 파트를 점(.)으로 구분합니다.헤더(Header) : 토큰의 타입과 해시 암호화 알고리즘(방식지정)으로 이루어져 있다.내용(Payload) : 토큰에 사용자가 담고자 하는 정보를 담는다. 내용에는 Claim이 담겨있고, JSON(Key/Value)형태의 한 쌍으로 이루어져 있다.서명(Signature) : 토큰을 인코딩하거나 유효성 검증할 때 사용하는 고유한 암호화 코드이다. 헤더와 내용의 값을 인코딩한다.JWT(Json Web Token) 란 무엇일까? (서버 기반 인증 / 토큰 기반 인증)"
    },
    {
        "question": "💡 대칭키, 비대칭키 암호화 방식에 대해 설명해주세요.",
        "answer": "대칭키와 비대칭키는 양방향 암호화 방식이며, 대칭키는 암호화와 복호화에 같은 암호 키를 쓰는 알고리즘입니다. 이는 중간에 누군가 암호 키를 가로채면 암호화된 정보가 유출될 수 있다는 단점이 있는데, 이런 문제를 보완한 새로운 방식이 비대칭키(공개키)입니다.비대칭키는 암호화와 복호화할 때 키를 서로 다른 키로 사용하는 암호화 알고리즘입니다. 타인에게 절대 노출되어서는 안되는 개인키(private key)와 공개적으로 개방되어 있는 공개키(public key)를 쌍으로 이룬 형태입니다."
    },
    {
        "question": "💡 Connection Timeout과 Read Timeout의 차이에 대해 설명해주세요.",
        "answer": "서버 자체에 클라이언트가 어떤 사유로 접근을 실패했을 시 적용되는 것이 Connection Timeout입니다.즉, 접근을 시도하는 시간 제한이 Connection Timeout 되는 것을 말합니다.클라이언트가 서버에 접속을 성공 했으나 서버가 로직을 수행하는 시간이 너무 길어 제대로 응답을 못 준 상태에서 클라이언트가 연결을 해제하는 것이 Read Timeout입니다.이 경우는 클라이언트는 해당 상황을 오류로 인지하고, 서버는 계속 로직을 수행하고 있어 성공으로 인지해 양 사이드간 싱크가 맞지 않아 문제가 발생할 확률이 높습니다."
    },
    {
        "question": "💡 공인(public) IP와 사설(private) IP의 차이에 대해 설명해주세요.",
        "answer": "공인 IP는 ISP(인터넷 서비스 공급자)가 제공하는 IP 주소이며, 외부에 공개되어 있는 IP주소 입니다.\n사설 IP는 일반 가정이나 회사 내 등에 할당된 네트워크 IP 주소이며, IPv4의 주소부족으로 인해 서브넷팅된 IP이기 때문에 라우터(공유기)에 의해 로컬 네트워크상의 PC나 장치에 할당됩니다.\n사설 IP 주소만으로는 인터넷에 직접 연결할 수 없고, 라우터를 통해 1개의 공인 IP를 할당하고, 라우터에 연결된 개인 PC는 사설 IP를 각각 할당 받아 인터넷에 접속 할 수 있습니다."
    },
    {
        "question": "1.  데이터 베이스의 특징 ?",
        "answer": "1. 실시간 접근성 (Real-Time Accessibility) - 비정형적인 질의에 대하여 실시간 처리에 의한 응답이 가능해야 함"
    },
    {
        "question": "2.  DDL, DML, DCL 이란 ?",
        "answer": "- DDL (Data Definition Language) : 데이터베이스의 구조를 정의, 수정, 삭제하는 언어 ( alter, create, drop)"
    },
    {
        "question": "3.  SELECT 쿼리의 수행 순서 ?",
        "answer": "FROM, ON, JOIN -> WHERE, GROUP BY, HAVING -> SELECT -> DISTINCT -> ORDER BY -> LIMIT"
    },
    {
        "question": "4.  Index 란 ,  장단점은 ?",
        "answer": "- Index란 테이블을 처음부터 끝까지 검색하는 방법인 FTS(Full Table Scan)과는 달리 인덱스를 검색하여 해당 자료의 테이블을 엑세스 하는 방법 [ DB를 책에 비유하자면 데이터는 책의 내용이고, 데이터가 저장된 레코드의 주소는 index 목록에 있는 페이지 번호일 것 ]"
    },
    {
        "question": "브라우저 주소창에 www.google.com을 입력하면 어떤 일이 일어나나요?",
        "answer": "주소창에 www.google.com을 입력하면 웹 브라우저는 우선 캐싱된 DNS기록을 찾아보고 기록에 없을 경우 DNS에게 도메인 주소를 요청하여 IP주소를 응답받습니다. 웹 브라우저는 IP 주소를 이용하여 웹 서버에게 HTTP 요청을 하고, 서버에게서 응답 받은 HTML을 화면에 출력합니다."
    },
    {
        "question": "GET과 POST의 차이는 무엇인가요?",
        "answer": "GET은 정보를 요청할 때 사용하는 메서드이고, POST는 서버에 데이터를 보내는데 사용됩니다."
    },
    {
        "question": "객체 지향 프로그래밍이란 무엇인가요?",
        "answer": "객체 지향 프로그래밍은 컴퓨터 프로그래밍 패러다임 중의 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 객체로 만들고 그 객체들 간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다."
    },
    {
        "question": "프로세스와 스레드에 대해 설명해주세요.",
        "answer": "프로세스는 메모리 상에서 실행중인 프로그램을 말하고, 스레드는 이 프로세스 안에서 실행되는 흐름 단위를 말합니다."
    },
    {
        "question": "DNS에 대해 설명해주세요.",
        "answer": "DNS는 URL과 IP 주소를 변환해주는 역할을 하는 시스템을 말합니다. IP는 숫자로 되어있어 사람이 이해하기 어렵기 때문에 사람이 알아볼 수 있는 URL로 변환하는 작업이 필요합니다."
    },
    {
        "question": "REST API에 대해 설명해주세요.",
        "answer": "REST를 기반으로 만들어진 API를 말합니다.\nREST는 HTTP를 기반으로 필요한 자원에 접근하는 방식을 정해놓은 아키텍처입니다.\nREST API는 자원(URI), 행위(HTTP 메서드), 표현(페이로드)으로 이루어져 있으며 HTTP 메서드를 사용해야 하고, URI가 리소스를 표현하는데 집중해야 합니다."
    },
    {
        "question": "Promise와 Callback의 차이를 설명해주세요.",
        "answer": "Callback은 비동기 로직의 결과값을 Callback 안에서만 처리를 할 수 있고, 콜백 밖에서 비동기로 온 값을 알 수 없습니다. 하지만 Promise는 비동기에서 온 값이 promise 객체에 저장되어서 코드 작성이 용이합니다."
    },
    {
        "question": "async, await의 사용 방법을 설명해주세요.",
        "answer": "함수 앞에 async키워드를 붙이면 이 함수는 항상 promise를 반환합니다.\nawait키워드는 async함수 안에서만 동작하는데, await키워드를 promise객체 앞에 붙이면 자바스크립트가 promise를 처리할 때까지 기다리고, 처리가 완료되면 에러가 발생하거나 promise객체의 result 값을 반환합니다."
    },
    {
        "question": "var, let, const의 차이를 설명해주세요.",
        "answer": "var는 중복 선언이 가능하고 선언과 동시에 초기화가 이루어지기 때문에 호이스팅이 발생하는 것 처럼 보여서 코드를 파악하기 힘듭니다.\nlet과 const는 선언만 이루어지고 초기화는 변수 선언문에서 이루어지기 때문에 호이스팅이 발생하지 않는 것 처럼 보입니다.\nlet은 중복 선언이 불가능하고, 재할당이 가능합니다.\nconst는 중복 선언과 재할당이 불가능합니다."
    },
    {
        "question": "이벤트 버블링과 캡처링에 대해 설명해주세요(예시와 함께).",
        "answer": "이벤트 버블링은 한 요소에 이벤트가 발생하면 최상단의 부모 요소의 이벤트까지 전파되는 것을 말합니다.\n이벤트 캡쳐는 이벤트 버블링과 반대로 최상위 태그에서 해당 태그로 이벤트가 전파되는 것을 말합니다."
    },
    {
        "question": "클로저에 대해 설명해주세요.",
        "answer": "클로저는 자신이 생성될 때의 환경을 기억하는 함수라고 할 수 있습니다.\n클로저는 외부 함수의 실행이 종료되어도 내부 함수에서 외부 함수를 참조하고 있다면 외부 함수 내 변수를 사용할 수 있습니다."
    },
    {
        "question": "실행 컨텍스트에 대해 설명해주세요.",
        "answer": "실행 컨텍스트는 실행할 코드에 제공할 환경 정보들을 모아놓은 객체입니다. 자바스크립트는 실행 컨텍스트를 콜스택에 쌓아올린 후 실행해서 코드의 환경과 순서를 보장할 수 있습니다."
    },
    {
        "question": "호이스팅에 대해 설명해주세요.",
        "answer": "호이스팅은 스코프 내의 선언을 해당 스코프의 최상단으로 끌어올린 것 처럼 보이는 현상을 말합니다. 자바스크립트 엔진은 런타임 이전에 실행 컨텍스트에 식별자의 정보를 등록하기 때문에 일어나는 현상입니다."
    },
    {
        "question": "불변성을 유지하려면 어떻게 해야하나요?",
        "answer": "객체의 불변성을 유지하려면 스프레드 문법을 사용하거나(얕은 복사만 가능), immer 라이브러리를 사용하거나 structuredClone 함수를 사용해 객체의 불변성을 유지할 수 있습니다."
    },
    {
        "question": "자바스크립트가 유동적인 언어인 이유는 무엇인가요?",
        "answer": "자바스크립트는 런타임 시점에 타입이 결정되는 동적 언어입니다. 매번 타입을 쓸 필요가 없기 때문에 빠르게 코드를 작성할 수 있습니다."
    },
    {
        "question": "this에 대해 설명해주세요.",
        "answer": "this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수입니다.\nthis를 통해 자신이 속한 객체나 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있습니다. this 바인딩은 함수 호출 방식에 의해 동적으로 결정됩니다."
    },
    {
        "question": "콜백 지옥(Callback hell)을 해결하는 방법을 말씀해주세요.",
        "answer": "콜백 지옥은 비동기 처리를 위해 콜백 함수를 연속해서 사용해서 코드가 깊어지는 것을 말합니다. 이를 해결하기 위해서는 Promise나 Async await을 사용하는 방법이 있습니다."
    },
    {
        "question": "Promise를 사용한 비동기 통신과 async, await를 사용한 비동기 통신의 차이를 설명해주세요.",
        "answer": "Promise를 사용하면 .catch()문을 통해 에러 핸들링이 가능하지만 async/await은 에러 핸들링 기능이 없어 try-catch문을 활용해야 합니다.\nasync/await은 비동기 코드가 동기 코드처럼 읽히게 해줘서 코드 흐름을 이해하기 쉽습니다."
    },
    {
        "question": "함수 선언형과 함수 표현식의 차이에 대해 설명해주세요.",
        "answer": "함수 선언식은 함수명이 정의되어 있고, 별도의 할당 명령이 없는 것을 말합니다.\n함수 표현식은 함수를 별도의 변수에 할당하는 것을 말합니다."
    },
    {
        "question": "렉시컬 환경(Lexical Environment)에 대해 설명해주세요.",
        "answer": "렉시컬 환경은 특정 코드가 선언된 환경을 말합니다."
    },
    {
        "question": "데이터 타입에 대해 설명해주세요.",
        "answer": "자바스크립트의 데이터 타입은 원시 타입과 객체 타입으로 나뉩니다. 원시 타입의 값은 변경 불가능한 값이며 값에 의한 전달이 일어납니다. 객체는 참조에 의한 전달이 일어납니다."
    },
    {
        "question": "깊은 복사와 얕은 복사에 대해 설명해주세요.",
        "answer": "얕은 복사는 참조 타입 데이터가 저장한 메모리 주소 값을 복사한 것을 말하고\n깊은 복사는 새로운 메모리 공간을 확보해 완전히 복사하는 것을 말합니다."
    },
    {
        "question": "requestAnimationFrame을 사용해본 적 있나요?",
        "answer": "requestAnimationFrame 메서드는 애니메이션 관련 최적화 API 입니다. 자바스크립트로 스타일을 변화시키는 방법은 CSS보다 성능이 좋지 않기 때문에 성능 최적화가 필요합니다.\nrequestAnimationFrame 함수는 시스템이 프레임을 그릴 준비가 되면 애니메이션 프레임을 호출합니다.\nrequestAnimationFrame을 사용하면 페이지가 비활성화 된 경우 페이지 화면 그리기 작업이 일시 중지되기 때문에 CPU 리소스를 낭비하지 않고, 모니터의 주사율을 따라 호출하기 때문에 별도의 반복 플래그가 필요 없습니다."
    },
    {
        "question": "Virtual DOM이 무엇이고 작동 원리에 대해 설명해주세요",
        "answer": "Virtual DOM은 실제 DOM의 복사본으로, JS 객체 형태로 메모리 안에 저장됩니다. 리액트는 state가 변경될 때 마다 re-rendering이 발생하는데, 이 시점마다 새로운 내용이 담긴 가상돔을 생성하게 됩니다. 렌더링 이전의 가상돔과 업데이트 이후의 가상돔을 비교해 차이가 발생한 부분만을 실제 DOM에 적용하게 됩니다. 리액트는 Batch Update를 통해 변경된 모든 Element들을 집단화 시켜 이를 한번에 실제 DOM에 적용시키기 때문에 효율적입니다."
    },
    {
        "question": "React를 사용하는 이유에 대해 말씀해주세요.",
        "answer": "가장 큰 이유는 컴포넌트 기반 개발이 가능하다는 점입니다.\n컴포넌트 단위 개발은 가독성이 좋고 재사용성, 확장성과 같은 이점이 있습니다.\n또한 리액트의 생태계는 여타 다른 라이브러리, 프레임워크 커뮤니티보다 활발하고, React를 기반으로 React Native를 활용해서 모바일 앱을 만들 수 있습니다."
    },
    {
        "question": "클래스형 컴포넌트와 함수형 컴포넌트의 차이에 대해 설명해주세요.",
        "answer": "클래스형 컴포넌트는 LifeCycle API를 사용하고, 함수형 컴포넌트에서는 Hook을 사용합니다.\n그리고 클래스형 컴포넌트는 this.props로 props를 받는데, this가 변경 가능한 object기 때문에 값이 달라질 수 있습니다. 함수 컴포넌트는 인자를 변경할 수 없기 때문에 렌더링 된 값들을 고정시킵니다."
    },
    {
        "question": "생명 주기 메서드에 대해 설명해주세요.",
        "answer": "리액트 컴포넌트는 생성(mount) > 업데이트(update) > 제거(unmount)의 생명주기를 갖습니다."
    },
    {
        "question": "리액트에서 JSX 문법이 어떻게 사용되나요?",
        "answer": "JSX는 Javascript에 XML을 추가한 문법으로 하나의 파일에 자바스크립트와 HTML을 동시에 작성할 수 있어서 편리합니다. 리액트 엔진은 JSX코드를 일반 자바스크립트 형태의 코드로 변환합니다."
    },
    {
        "question": "왜 state를 직접 바꾸지 않고 useState를 사용해야 하나요?",
        "answer": "리액트는 메모리 주소를 통해 값이 변경되었다는 것을 판단하기 때문에 새로운 객체를 만들어서 할당해야 합니다. 따라서 이를 위해 useState를 사용해야 합니다.(setState가 실행되면 새 scope를 만들어 state 변수도 새로 만들게 된다.)"
    },
    {
        "question": "useMemo와 useCallback에 대해 설명해주세요.",
        "answer": "useMemo는 메모이제이션된 값을 return하는 hook이고, useCallback은 메모이제이션된 함수를 반환하는 hook입니다."
    },
    {
        "question": "+ useMemo와 useState의 차이",
        "answer": "useMemo는 의존성에 따라 값이 자동적으로 바뀌는 경우에 사용한다."
    },
    {
        "question": "+ useMemo, React.memo",
        "answer": "useMemo는 hook이라서 함수형 컴포넌트에서만 사용 가능하고,\nReact.memo는 클래스형 컴포넌트와 함수형 컴포넌트에서 사용 가능합니다.\nuseMemo는 리턴되는 값을 메모이제이션 하는데, 의존성 배열에 있는 값이 바뀌는 경우 호출됩니다.\nReact.memo는 컴포넌트를 메모이제이션하는데, 컴포넌트의 props가 바뀌지 않으면 리렌더링 하지 않습니다."
    },
    {
        "question": "리액트에서 메모이제이션을 어떤 방식으로 하나요?",
        "answer": "리액트에서 메모이제이션은 React.memo, useCallback, useMemo를 통해 사용할 수 있습니다."
    },
    {
        "question": "리액트의 렌더링 성능 향상을 위해 어떻게 해야 하나요?",
        "answer": "useMemo, React.memo, useCallback의 사용,\n자식 컴포넌트의 props로 객체를 넘겨줄 때 객체를 변형하거나 새로 생성하지 않고 그대로 넘겨주기, 컴포넌트를 매핑할 때 key값으로 index를 사용하지 않기, useState의 함수형 업데이트 사용, 디바운싱과 쓰로틀링 적용 등이 있습니다."
    },
    {
        "question": "React-query에 대해 설명해주세요.",
        "answer": "React-query는 React 환경에서의 비동기 Query(질의)과정을 도와주는 라이브러리입니다.\nReact-query는 데이터를 캐싱해서 반복적인 데이터 호출을 방지하고, 서버 데이터와 클라이언트 데이터를 분리하고(클라이언트 데이터는 상태 관리 라이브러리가 관리하고, 서버 데이터는 React-query가 관리), useQuery가 반환하는 isLoading과 error객체를 통해 상황별 분기 처리를 쉽게 진행할 수 있습니다."
    },
    {
        "question": "React 18 버전 업데이트 내용에 대해 말씀해주세요.",
        "answer": "새로운 Root API(ReactDOM.createRoot)가 적용되었습니다.\nReact Event Handler뿐만 아니라 promise, setTimeout, native event handler 등 다양한 로직에서 Batching 작업이 가능해졌습니다.\nReact에서 제공해주는 API를 통해 CRA에서도 SSR을 활용한 아키텍처를 설계할 수 있습니다.\nSuspense를 통해 Streaming HTML과 Selective Hydration을 사용할 수 있습니다.."
    },
    {
        "question": "useEffect와 useLayoutEffect의 차이점에 대해 말씀해주세요.",
        "answer": "useEffect는 비동기적으로 렌더링 후에 호출되고, useLayoutEffect는 동기적으로, paint가 되기 전에 실행됩니다. useLayoutEffect는 애니메이션 구현 등 즉시 반응이 필요한 경우나 성능 모니터링의 경우 사용하면 좋습니다."
    },
    {
        "question": "ContextAPI에 대해 설명해주세요.",
        "answer": "Context는 리액트 컴포넌트 간에 값을 공유할 수 있게 해주는 기능으로, 주로 전역적으로 필요한 값을 다룰때 사용합니다."
    },
    {
        "question": "Key Props를 사용하는 이유는 무엇인가요?",
        "answer": "map을 사용할 때 리액트가 key를 통해 어떤 항목을 변경, 추가 삭제할지 식별하기 때문에 엘리멘트의 고유성을 부여하기 위해 key를 지정해야 합니다."
    },
    {
        "question": "제어 컴포넌트와 비제어 컴포넌트의 차이에 대해 설명해주세요.",
        "answer": "제어 컴포넌트는 사용자의 입력을 기반으로 자신의 state를 관리하고 업데이트합니다.(setState()사용)\n비제어 컴포넌트는 기존의 바닐라 스크립트와 같이 사용자가 직접 트리거 하기 전까지 리렌더링을 발생시키지 않고 값을 동기화 시키지도 않습니다.(ref사용)"
    },
    {
        "question": "props와 state의 차이는 무엇인가요?",
        "answer": "props는 부모 컴포넌트에서 상속 받는 데이터로 데이터를 변경할 수 없습니다.\nstate는 자기 자신의 컴포넌트에서 만들어낸 데이터이며 변경할 수 있습니다."
    },
    {
        "question": "pure component에 대해 설명해주세요.",
        "answer": "pureComponent는 shouldComponentUpdate()안에 얕은 비교가 적용된 버전입니다.\n즉, pureComponent를 사용하면 리액트의 성능을 향상시키는 데 가장 중요한 것 중 하나인 shouldComponentUpdate를 신경쓰지 않아도 됩니다."
    },
    {
        "question": "shouldComponentUpdate에 대해 설명해주세요.",
        "answer": "shouldComponentUpdate()는 props또는 state가 새로운 값으로 갱신되어 렌더링이 발생하기 직전에 호출됩니다. shouldComponentUpdate()을 사용하면 조건에 따라 데이터가 변경되어 렌더링이 필요한 경우에만 렌더링 작업을 수행할 수 있습니다."
    },
    {
        "question": "리액트 관련 패키지 중에 제일 좋다고 생각한 것은 무엇인가요?",
        "answer": "styled-components입니다. css에 js를 적용할 수 있고, 스타일 컴포넌트의 변수명에 해당 컴포넌트의 기능을 넣었을 때 가독성이 좋아진다고 느꼈습니다."
    }
]